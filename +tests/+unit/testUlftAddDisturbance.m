%% Requirements:
%  1. addDisturbance shall take a cell array of disturbances and append the
%      provided disturbances to the disturbances that are already present 
%      in the given LFT.
%  2. An error shall be thrown if addDisturbance attempts to add a 
%      disturbance which is not consistent with the given LFT. 
%     Inconsistent disturbances:
%       - specify signal channels which exceed the size of the LFT
%       - share names with other disturbances but are not equivalent to 
%         those disturbances

%%
%  Copyright (c) 2021 Massachusetts Institute of Technology 
%  SPDX-License-Identifier: GPL-2.0
%%

%% Test class for Ulft.
classdef testUlftAddDisturbance < matlab.unittest.TestCase

methods (TestMethodSetup)
function seedAndReportRng(testCase)
    seed = floor(posixtime(datetime('now')));
    rng('default');
    rng(seed);
    diagnose_str = ...
        sprintf(['If this test generates random inputs, those inputs',...
                 ' may be regenerated by calling: \n',...
                 '>> rng(%10d) \n',...
                 'before running the remainder of the test''s body'],...
                seed);
    testCase.onFailure(@() fprintf(diagnose_str));
end    
end
    
methods (Test)
    
function testAddDisturbancesToNoDisturbances(testCase) 
    chars = ['A':'Z', 'a':'z', '0':'9'];
    for i = 1:10
        % Create lft and disturbances
        lft = Ulft.random();
        num_disturbance = randi([1, 5]);
        disturbances = cell(1, num_disturbance);
        for j = 1 : num_disturbance 
            name = chars(randi(length(chars), [1, 5]));
            disturbances{j} = DisturbanceL2(name);
        end
        lft_added = lft.addDisturbance(disturbances);
        lft_correct = Ulft(lft.a, lft.b, lft.c, lft.d, lft.delta,...
                           'horizon_period', lft.horizon_period,...
                           'disturbance', disturbances);
        
        assertEqual(testCase, lft.disturbance.names, {'default_l2'})
        
        % Check addition of disturbances
        verifyEqual(testCase, lft_added, lft_correct)
        
        % Check that adding different disturbances creates different LFTs
        lft_wrong = addDisturbance(lft, {DisturbanceL2('another')});
        verifyNotEqual(testCase, lft_wrong, lft_correct)
    end
end

function testAddDuplicateDisturbances(testCase) 
    chars = ['A':'Z', 'a':'z', '0':'9'];
    for i = 1:10
        % Create lft and disturbances
        lft = Ulft.random();
        num_disturbance = randi([1, 5]);
        disturbances = cell(1, num_disturbance);
        for j = 1 : num_disturbance 
            name = chars(randi(length(chars), [1, 5]));
            disturbances{j} = DisturbanceL2(name);
        end
        lft = lft.addDisturbance(disturbances);
        seq_dis = SequenceDisturbance(disturbances);
        seq_dis = matchHorizonPeriod(seq_dis, lft.horizon_period);
        lft_duplicate = lft.addDisturbance(seq_dis.disturbances);
        
        % Check that duplicate disturbances are unified
        verifyEqual(testCase, lft_duplicate, lft)
    end
end

function testAddDisturbancesToDisturbances(testCase) 
    chars = ['A':'Z', 'a':'z', '0':'9'];
    for i = 1:10
        % Create lft and disturbances
        lft = Ulft.random();
        num_disturbance = 2 * randi([1, 3]);
        disturbances = cell(1, num_disturbance);
        for j = 1 : num_disturbance 
            name = chars(randi(length(chars), [1, 5]));
            disturbances{j} = DisturbanceL2(name);
        end
        orig_inds = 1 : num_disturbance / 2;
        add_inds = (num_disturbance / 2) + 1 : num_disturbance;
        lft = Ulft(lft.a, lft.b, lft.c, lft.d, lft.delta,...
                           'horizon_period', lft.horizon_period,...
                           'disturbance', disturbances(orig_inds));
        lft_added = lft.addDisturbance(disturbances(add_inds));
        lft_correct = Ulft(lft.a, lft.b, lft.c, lft.d, lft.delta,...
                           'horizon_period', lft.horizon_period,...
                           'disturbance', disturbances);
        
        % Check addition of disturbances
        verifyEqual(testCase, lft_added, lft_correct)
    end
end

function testErrorAddingUnequalDisturbances(testCase) 
    for i = 1:10
        % Create lfts with nearly equivalent disturbances
        horizon_period1 = [randi([1, 5]), randi([2, 5])];
        lft = Ulft.random('horizon_period', horizon_period1);
        dis1 = DisturbanceL2('a', {1}, horizon_period1);
        lft1 = Ulft(lft.a, lft.b, lft.c, lft.d, lft.delta,...
                    'horizon_period', lft.horizon_period,...
                    'disturbance', dis1); 
        
        horizon_period2 = horizon_period1 - 1;
        lft = Ulft.random('horizon_period', horizon_period2);
        dis2 = DisturbanceL2('a', {1}, horizon_period2);
        lft2 = Ulft(lft.a, lft.b, lft.c, lft.d, lft.delta,...
                    'horizon_period', lft.horizon_period,...
                    'disturbance', dis2);
                
        horizon_period3 = [0, 1];
        lft = Ulft.random('horizon_period', horizon_period3);
        dis3 = DisturbanceL2('a', {1}, horizon_period3);
        lft3 = Ulft(lft.a, lft.b, lft.c, lft.d, lft.delta,...
                    'horizon_period', lft.horizon_period,...
                    'disturbance', dis3);
            
        % Check that error is thrown when unequal disturbances are added
        verifyError(testCase, @() addDisturbance(lft1, {dis2}), ?MException)
        verifyError(testCase, @() addDisturbance(lft1, {dis3}), ?MException)
        verifyError(testCase, @() addDisturbance(lft3, {dis1}), ?MException)
    end
end

function testErrorAddDisturbanceBadChannels(testCase)
    for i = 1:10
       lft = Ulft.random();
       dim_in  = size(lft, 2);
       % This disturbance has too many channels
       dis = DisturbanceL2('a', {[1 : 2 : dim_in(1), dim_in(1) + 1]'});
       % Try to add to an LFT
       verifyError(testCase, @() addDisturbance(lft, {dis}), ?MException)
    end
end
    
end
end

%%  CHANGELOG
% Sep. 28, 2021 (v0.6.0)
% Aug. 26, 2021 (v.0.5.0): Initial release - Micah Fry (micah.fry@ll.mit.edu)