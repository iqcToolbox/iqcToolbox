%% Requirements:
%  1. Ulft.mtimes shall preform the multiplication operation 
%  between two LFTs.
%     1.1. If multiplying the operand LFTs does not necessitate reordering 
%          Deltas, the output LFT is as expressed in Section 2.4 of 
%          "A Review of LFTs, LMIs and Mu" (1991). Reordering Deltas is 
%          necessitated when any of the following conditions hold:
%           - DeltaDelayZ appears in the 2nd operand LFT
%           - DeltaIntegrator appears in the 2nd operand LFT
%           - Either operand LFT contains the same Delta
%
%  2. Ulft.mtimes shall throw an error if the two LFTs are not conformable.
%     a) A pair of LFTs conformable to multiplication must:
%        - have no specified performances
%     b) The leftmost LFT in a conformable pair must:
%        - have the input of the leftmost lft match the rightmost lft
%        - have the no specified disturbances
%
%  3. Ulft.mtimes shall output an LFT that does not have duplicates of the 
%     same delta.
%
%  4. Ulft.mtimes shall be capable of taking one input argument that is not 
%     a Ulft object, as long as the input argument can be converted to a 
%     Ulft. If the non-Ulft input is not convertible, an error shall be 
%     thrown. Objects convertible to Ulfts are:
%       - doubles
%       - Delta objects
%       - ss objects
%
%  5. If the Ulft.mtimes operands have different horizon_periods, 
%     Ulft.mtimes shall ensure that the output Ulft shall have a resulting 
%     horizon_period that is consistent with the horizon_periods of both 
%     operands.
%

%%
%  Copyright (c) 2021 Massachusetts Institute of Technology 
%  SPDX-License-Identifier: GPL-2.0
%%

%% Test class for Ulft.
classdef testUlftMtimes < matlab.unittest.TestCase
    
methods (TestMethodSetup)
    function seedAndReportRng(testCase)
        seed = floor(posixtime(datetime('now')));
        rng('default');
        rng(seed, 'twister');
        diagnose_str = ...
            sprintf(['Random inputs may be regenerated by calling: \n',...
                     '>> rng(%10d) \n',...
                     'before running the remainder of the test''s body'],...
                    seed);
        testCase.onFailure(@() fprintf(diagnose_str));
    end    
end
    
methods (Test)

% lft example
function testMtimesDeterministic(testCase)
    % REQUIREMENT 1
    % Create simple lft with standard Z
    z = DeltaDelayZ();
    a = {0};
    b = {1};
    c = {1};
    d = {0};
    lfti_l = Ulft(a, b, c, d, z);
    
    % Create simple lft with standard Z
    lfti_r = Ulft(a, b, c, d, z);
    
    lfti_product = lfti_l * lfti_r;
    
    % Define function handles for mtimes product matrices
    productA = @(left_a, right_a, left_b, right_c) ...
               tests.unit.testUlftMtimes.productA(left_a, right_a, ...
                                                  left_b, right_c); 
    productB = @(left_b, right_b, right_d) ...
               tests.unit.testUlftMtimes.productB(left_b, right_b, right_d);
    productC = @(left_c, right_c, left_d) ...
               tests.unit.testUlftMtimes.productC(left_c, right_c, left_d);
    productD = @(left_d, right_d) ...
               tests.unit.testUlftMtimes.productD(left_d, right_d);

   
    % Verify equality of product to matrix from paper
    verifyEqual(testCase, lfti_product.a{1}, ...
                productA(lfti_l.a{1}, lfti_r.a{1}, lfti_l.b{1}, lfti_r.c{1}))
    verifyEqual(testCase, lfti_product.b{1}, ...
                productB(lfti_l.b{1}, lfti_r.b{1}, lfti_r.d{1}))
    verifyEqual(testCase, lfti_product.c{1}, ...
                productC(lfti_l.c{1}, lfti_r.c{1}, lfti_l.d{1}))
    verifyEqual(testCase, lfti_product.d{1}, ...
                productD(lfti_l.d{1}, lfti_r.d{1}))
end

function testMtimesNoGather(testCase)
    
    % Define function handles for mtimes product matrices
    productA = @(left_a, right_a, left_b, right_c) ...
               tests.unit.testUlftMtimes.productA(left_a, right_a, ...
               left_b, right_c); 
    productB = @(left_b, right_b, right_d) ...
               tests.unit.testUlftMtimes.productB(left_b, right_b, right_d);
    productC = @(left_c, right_c, left_d) ...
               tests.unit.testUlftMtimes.productC(left_c, right_c, left_d);
    productD = @(left_d, right_d) ...
               tests.unit.testUlftMtimes.productD(left_d, right_d);

    % Run test n times
    n = 10;
    for i = 1 : n
        % _______________First Test_______________%
        % -- LTI -- %
        % Create LTI lfts
        lfti_l = Ulft.random('horizon_period', [0 1]);
        left_input = size(lfti_l, 2);
        lfti_r = Ulft.random('horizon_period', [0 1], ...
                             'dim_out', left_input(1), ...
                             'num_deltas', randi([2 10]));
        lfti_r = lfti_r.removeUncertainty(1);

        lfti_product = lfti_l * lfti_r;
        
        % Verify equality of product to matrix from paper
        verifyEqual(testCase, lfti_product.a{1}, ...
                    productA(lfti_l.a{1}, lfti_r.a{1}, lfti_l.b{1}, ...
                             lfti_r.c{1}))
        verifyEqual(testCase, lfti_product.b{1}, ...
                    productB(lfti_l.b{1}, lfti_r.b{1}, lfti_r.d{1}))
        verifyEqual(testCase, lfti_product.c{1}, ...
                    productC(lfti_l.c{1}, lfti_r.c{1}, lfti_l.d{1}))
        verifyEqual(testCase, lfti_product.d{1}, ...
                    productD(lfti_l.d{1}, lfti_r.d{1}))

        % -- LTV -- %
        % Create LTV lfts
        lftv_l = Ulft.random('horizon_period', randi([1 10], 1, 2));
        left_input = size(lftv_l, 2);
        lftv_r = Ulft.random('horizon_period', randi([1 10], 1, 2), ...
                             'dim_out', left_input(1), ...
                             'num_deltas', randi([2 10]));
        lftv_r = lftv_r.removeUncertainty(1);
        lftv_product = lftv_l * lftv_r;

        [il, ~] = makeNewIndices(lftv_l.horizon_period, ...
                                 lftv_product.horizon_period);
        [ir, ~] = makeNewIndices(lftv_r.horizon_period, ...
                                 lftv_product.horizon_period);
                                    
        total_time = sum(lftv_product.horizon_period);
        for j = 1 : total_time
            verifyEqual(testCase, lftv_product.a{j}, ...
                        productA(lftv_l.a{il(j)}, lftv_r.a{ir(j)}, ...
                                 lftv_l.b{il(j)}, lftv_r.c{ir(j)}))
            verifyEqual(testCase, lftv_product.b{j}, ...
                        productB(lftv_l.b{il(j)}, lftv_r.b{ir(j)}, ...
                                 lftv_r.d{ir(j)}))
            verifyEqual(testCase, lftv_product.c{j}, ...
                        productC(lftv_l.c{il(j)}, lftv_r.c{ir(j)}, ...
                                 lftv_l.d{il(j)}))
            verifyEqual(testCase, lftv_product.d{j}, ...
                        productD(lftv_l.d{il(j)}, lftv_r.d{ir(j)}))
        end
    end
end
function testMtimesGather(testCase)
    
    % Define function handles for mtimes product matrices
    productA = @(left_a, right_a, left_b, right_c) ...
               tests.unit.testUlftMtimes.productA(left_a, right_a, ...
               left_b, right_c); 
    productB = @(left_b, right_b, right_d) ...
               tests.unit.testUlftMtimes.productB(left_b, right_b, right_d);
    productC = @(left_c, right_c, left_d) ...
               tests.unit.testUlftMtimes.productC(left_c, right_c, left_d);
    productD = @(left_d, right_d) ...
               tests.unit.testUlftMtimes.productD(left_d, right_d);

    % Run test n times
    n = 10;
    for i = 1 : n
        % _______________Second Test_______________%
        % -- LTI -- %
        % Create LTI lfts
        lfti_l = Ulft.random('horizon_period', [0 1], ...
                             'req_deltas', {DeltaDelayZ()}, ...
                             'num_deltas', 1);
        left_input = size(lfti_l, 2);
        lfti_r = Ulft.random('horizon_period', [0 1], ...
                             'dim_out', left_input(1), ...
                             'req_deltas', {DeltaDelayZ()}, ...
                             'num_deltas', randi([2 10]));

        lfti_product = lfti_l * lfti_r;

        % Verify equality of product to reordered matrix from lemma
        verifyEqual(testCase, lfti_product.a{1}, ...
                    productA(lfti_l.a{1}, lfti_r.a{1}, lfti_l.b{1}, ...
                             lfti_r.c{1}))
        verifyEqual(testCase, lfti_product.b{1}, ...
                    productB(lfti_l.b{1}, lfti_r.b{1}, lfti_r.d{1}))
        verifyEqual(testCase, lfti_product.c{1}, ...
                    productC(lfti_l.c{1}, lfti_r.c{1}, lfti_l.d{1}))
        verifyEqual(testCase, lfti_product.d{1}, ...
                    productD(lfti_l.d{1}, lfti_r.d{1}))
                
        % -- LTV -- %
        % Create LTV lfts
        lftv_l = Ulft.random('horizon_period', randi([1 10], 1, 2), ...
                            'num_deltas', 1, ...
                            'req_delta', {DeltaDelayZ()}); 
        left_input = size(lftv_l, 2);
        lftv_r = Ulft.random('horizon_period', randi([1 10], 1, 2), ...
                            'dim_out', left_input(1), ...
                            'num_deltas', randi([2 10]), ...
                            'req_delta', {DeltaDelayZ()});
        lftv_product = lftv_l * lftv_r;

        [il, ~] = makeNewIndices(lftv_l.horizon_period, ...
                                 lftv_product.horizon_period);
        [ir, ~] = makeNewIndices(lftv_r.horizon_period, ...
                                 lftv_product.horizon_period);
                                    
        total_time = sum(lftv_product.horizon_period);
        for j = 1 : total_time
            verifyEqual(testCase, lftv_product.a{j}, ...
                        productA(lftv_l.a{il(j)}, lftv_r.a{ir(j)}, ...
                                 lftv_l.b{il(j)}, lftv_r.c{ir(j)}))
            verifyEqual(testCase, lftv_product.b{j}, ...
                        productB(lftv_l.b{il(j)}, lftv_r.b{ir(j)}, ...
                                 lftv_r.d{ir(j)}))
            verifyEqual(testCase, lftv_product.c{j}, ...
                        productC(lftv_l.c{il(j)}, lftv_r.c{ir(j)}, ...
                                 lftv_l.d{il(j)}))
            verifyEqual(testCase, lftv_product.d{j}, ...
                        productD(lftv_l.d{il(j)}, lftv_r.d{ir(j)}))
        end
    end
    
end

function testMtimesConformablePerf(testCase)
    % REQUIREMENT 2

    % Run test n times
    n = 10;
    for i = 1 : n
        % - LTI
        lfti_no_perf_left = Ulft.random('req_deltas', {DeltaIntegrator()});
        right_dim = size(lfti_no_perf_left, 2);
        lfti_perf_left = lfti_no_perf_left;
        lfti_perf_left = addPerformance(lfti_perf_left, ...
                                        {PerformanceL2Induced('testperf')});
        lfti_perf_right = Ulft.random('req_deltas', {DeltaIntegrator()}, ...
                                      'dim_out', right_dim(1));
        lfti_perf_right = addPerformance(lfti_perf_right, ...
                                         {PerformanceL2Induced('testperf')}); 
        
        % One lft has a specified performance
        verifyError(testCase,...
            @() mtimes(lfti_no_perf_left, lfti_perf_right), ?MException)
        
        % Both lfts have a specified performance
        verifyError(testCase,...
            @() mtimes(lfti_perf_left, lfti_perf_right), ?MException)
        
        
        % - LTV
        lftv_no_perf_left = Ulft.random('horizon_period', ...
                                        randi([1 10], 1, 2), ...
                                        'req_deltas', {DeltaDelayZ()});
        right_dim = size(lftv_no_perf_left, 2);
        lftv_perf_left = lftv_no_perf_left;
        lftv_perf_left = addPerformance(lftv_perf_left, ...
                                        {PerformanceL2Induced('testperf')});
        lftv_perf_right = Ulft.random('horizon_period', ...
                                      randi([1 10], 1, 2), 'dim_out', ...
                                      right_dim(1));
        lftv_perf_right = addPerformance(lftv_perf_right, ...
                                        {PerformanceL2Induced('testperf')});
        
        % One lft has a specified performance
        verifyError(testCase,...
            @() mtimes(lftv_no_perf_left, lftv_perf_right), ?MException)

        % Both lfts have a specified performance
         verifyError(testCase,...
            @() mtimes(lftv_perf_left, lftv_perf_right), ?MException)
    end
end
function testMtimesConformableDist(testCase)
    % Run test n times
    n = 10;
    for i = 1 : n
        % - LTI
        lfti_dist_left = Ulft.random('req_deltas', {DeltaIntegrator()});
        lfti_dist_left = addDisturbance(lfti_dist_left, ...
                                        {DisturbanceL2('testdist')});
        right_dim = size(lfti_dist_left, 2);
        lfti_no_dist_right = Ulft.random('req_deltas', ...
                                        {DeltaIntegrator()}, ...
                                        'dim_out', right_dim(1));
        
        
        % The left lft has a specified disturbance
        verifyError(testCase,...
            @() mtimes(lfti_dist_left, lfti_no_dist_right), ?MException)
        
        % - LTV
        lftv_dist_left = Ulft.random('horizon_period', ...
                                     randi([1 10], 1, 2), ...
                                     'req_deltas', {DeltaDelayZ()});
        lftv_dist_left = addDisturbance(lftv_dist_left, ...
                                        {DisturbanceL2('testdist')});
        right_dim = size(lftv_dist_left, 2);
        lftv_no_dist_right = Ulft.random('horizon_period', ...
                                        randi([1 10], 1, 2), ...
                                        'req_deltas', {DeltaDelayZ()}, ...
                                        'dim_out', right_dim(1));
        
        % The left lft has a specified disturbance
        verifyError(testCase,...
            @() mtimes(lftv_dist_left, lftv_no_dist_right), ?MException) 

    end
end

function testMtimesConformableSize(testCase)
    % Run test n times
    n = 10;
    for i = 1 : n
        % - LTI
        lfti_l_input = Ulft.random('req_deltas', {DeltaDelayZ()}, ...
                                   'dim_in', 5);
        lfti_r_output = Ulft.random('req_deltas', {DeltaDelayZ()}, ...
                                    'dim_out', 6);
        
        % The input size of the left lft doesn't match the output size of right
        verifyError(testCase,...
            @() mtimes(lfti_l_input, lfti_r_output), ?MException)
        
        % - LTV
        lftv_l_input = Ulft.random('horizon_period', ...
                                    randi([1 10], 1, 2), ...
                                    'dim_in', 5);
        lftv_r_output = Ulft.random('horizon_period', ...
                                    randi([1 10], 1, 2), ...
                                    'dim_out', 6);

        % The input size of the left lft doesn't match the output size of right
        verifyError(testCase,...
            @() mtimes(lftv_l_input, lftv_r_output), ?MException) 
    end
end 

function testMtimesDeltaDuplicates(testCase)
    % REQUIREMENT 3
    
    % - Deterministic LTI
    % Create lfts from static time-invariant uncertainties
    d = DeltaSlti('a');
    d1 = DeltaSlti('a');
    d_lft = toLft(d);
    d1_lft = toLft(d1);
    
    % Check that no delta duplicates exist
    d_product = d_lft * d1_lft;
    del = d_product.delta.names;
        verifyEqual(testCase, length(unique(del)), length(del))

    % Run test n times
    n = 10;
    for i = 1 : n
        % - LTI
        % Define the lfts
        lfti_l = Ulft.random('horizon_period', [0, 1]);
        dim_out = size(lfti_l, 2);
        lfti_r = Ulft.random('horizon_period', [0, 1], ...
                             'req_deltas', lfti_l.delta.deltas, ...
                             'dim_out', dim_out(1));
        
        % Multiply the lfts
        lfti_product = lfti_l * lfti_r;
        
        % Check that no delta duplicates exist
        deli = lfti_product.delta.names;
        verifyEqual(testCase, length(unique(deli)), length(deli))
        
        % - LTV
        % Define the lfts
        randHp = randi([1 10], 1, 2);
        lftv_l = Ulft.random('horizon_period', randHp);
        dim_out = size(lftv_l, 2);
        lftv_r = Ulft.random('horizon_period', randHp, ...
                             'req_deltas', lftv_l.delta.deltas, ...
                             'dim_out', dim_out(1));

        % Multiply the lfts
        lftv_product = lftv_l * lftv_r; 

        % Check that no delta duplicates exist
        delv = lftv_product.delta.names;
        verifyEqual(testCase, length(unique(delv)), length(delv))
    end
end

function testMtimesNonLftDeterministic(testCase)
    % REQUIREMENT 4
    % Ensure failure of multiplication of non-lft ojects
    
    % Discrete time lft
    z = DeltaDelayZ();
    a = {0};
    b = {1};
    c = {1};
    d = {0};
    lft1 = Ulft(a, b, c, d, z);
    
    % Continuous time lft
    s = DeltaIntegrator();
    lft2 = Ulft(a, b, c, d, s);
    
    % Convertible non-lft objects
    lft_double = 3;
    lft_delta = DeltaSlti('a');
    lft_ss_cont = ss(1, 1, 1, 1);
    lft_ss_disc = ss(1, 1, 1, 1, -1);
    
    obj = 'non-convertible';
    
    % non-lft object is right
    lft_a1 = mtimes(lft1, lft_double);
    lft_a3 = mtimes(lft1, lft_delta);
    lft_a4 = mtimes(lft1, lft_ss_disc);
    lft_a5 = mtimes(lft2, lft_ss_cont);
    
    verifyClass(testCase, lft_a1, 'Ulft') 
    verifyClass(testCase, lft_a3, 'Ulft') 
    verifyClass(testCase, lft_a4, 'Ulft') 
    verifyClass(testCase, lft_a5, 'Ulft') 
    
    % non-lft object is left
    lft_b1 = mtimes(lft_double, lft1);
    lft_b3 = mtimes(lft_delta, lft1);
    lft_b4 = mtimes(lft_ss_disc, lft1);
    lft_b5 = mtimes(lft_ss_cont, lft2);
    
    verifyClass(testCase, lft_b1, 'Ulft') 
    verifyClass(testCase, lft_b3, 'Ulft') 
    verifyClass(testCase, lft_b4, 'Ulft') 
    verifyClass(testCase, lft_b5, 'Ulft')
    
end
    
function testMtimesNonLftRandom(testCase)
    % REQUIREMENT 4
    % Ensure failure of multiplication of non-lft ojects
        
    % Define lfts
    % Discrete time lft
    z = DeltaDelayZ();
    a = {0};
    b = {1};
    c = {1};
    d = {0};
    lft1 = Ulft(a, b, c, d, z);
    
    % - LTI
    lfti_l = Ulft.random('req_deltas', {DeltaIntegrator()});
    lfti_r = Ulft.random('req_deltas', {DeltaIntegrator()}, ...
                         'dim_out', 1);
    
    lfti_l_disc = Ulft.random('req_deltas', {DeltaDelayZ()});
    lfti_r_disc = Ulft.random('req_deltas', {DeltaDelayZ()}, ...
                              'dim_out', 1);
    
    lfti_l_size = size(lfti_l, 2);
    lfti_l_disc_size = size(lfti_l_disc, 2);
    % Convertible non-lft objects
    lft_double = ones(lfti_l_size, 1);
    lft_delta = DeltaSlti('a');
    lft_ss_cont = ss(1, 1, ones(lfti_l_size, 1), ...
        ones(lfti_l_size, 1));
    lft_ss_disc = ss(1, 1, ones(lfti_l_disc_size, 1), ...
        ones(lfti_l_disc_size, 1), -1);
    
    obj = 'non-convertible';
    
    % non-lft object is right
    lft_a1 = mtimes(lfti_l, lft_double);
    lft_a3 = mtimes(lft1, lft_delta);
    lft_a4 = mtimes(lfti_l, lft_ss_cont);
    lft_a5 = mtimes(lfti_l_disc, lft_ss_disc);
    
    verifyClass(testCase, lft_a1, 'Ulft') 
    verifyClass(testCase, lft_a3, 'Ulft') 
    verifyClass(testCase, lft_a4, 'Ulft') 
    verifyClass(testCase, lft_a5, 'Ulft') 
    
    % non-lft object is left
    lft_b1 = mtimes(lft_double, lfti_r);
    lft_b3 = mtimes(lft_delta, lft1);
    lft_b4 = mtimes(lft_ss_disc, lfti_r_disc);
    lft_b5 = mtimes(lft_ss_cont, lfti_r);
    
    verifyClass(testCase, lft_b1, 'Ulft') 
    verifyClass(testCase, lft_b3, 'Ulft') 
    verifyClass(testCase, lft_b4, 'Ulft') 
    verifyClass(testCase, lft_b5, 'Ulft') 
    
    % non-convertible non-lft object - right
    verifyError(testCase, @() mtimes(lfti_l, obj), ?MException)
    % non-convertible non-lft object - left
    verifyError(testCase, @() mtimes(obj, lfti_r), ?MException)
    
end

function testMtimesCommonHp(testCase)
    % REQUIREMENT 5
    z = DeltaDelayZ();
    a = {0};
    b = {1};
    c = {1};
    d = {0};
    a1 = {1, 1, 1, 1};
    b1 = {1, 1, 1, 1};
    c1 = {1, 1, 1, 1};
    d1 = {0, 0, 0, 0};
    lft1 = Ulft(a, b, c, d, z, 'horizon_period', [0 1]);
    lft2 = Ulft(a1, b1, c1, d1, z, 'horizon_period', [2 2]);
    correct_hp = [2 2];
    lftm = mtimes(lft1, lft2);
    verifyEqual(testCase, lftm.horizon_period, correct_hp)
end
end
methods (Static)
    
function a = productA(left_a, right_a, left_b, right_c)
    a = [left_a, left_b * right_c;  
         zeros(size(right_a, 1), size(left_a, 2)), ...
         right_a];
end

function b = productB(left_b, right_b, right_d)
    b = [left_b * right_d; right_b];
end

function c = productC(left_c, right_c, left_d)
    c = [left_c, left_d * right_c];
end

function d = productD(left_d, right_d)
    d = left_d * right_d;
end

end
end

%%  CHANGELOG
% Sep. 28, 2021 (v0.6.0): Removed tests for implicitly converting cells of doubles - Micah Fry (micah.fry@ll.mit.edu)
% Aug. 26, 2021 (v.0.5.0): Initial release - Zakariya Laouar (zakariya.laouar@ll.mit.edu)