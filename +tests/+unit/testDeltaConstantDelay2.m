%% Requirements:
%  1. DeltaConstantDelay2 shall be defined by it's name, the input/output
%      dimension, the maximum allowable delay, and the
%      horizon_period
%  2. Upon construction, and when queried by user, it shall display the
%      information described in (1).
%
%  3. If input/output dimenstion is not provided by the user, by
%      default the in/out dimension shall be 1, the maximum delay shall be 1, 
%      and the horizon_period shall be [0, 1].
%
%  4. If the user provides no name, DeltaConstantDelay2 shall throw an 
%      exception
%
%  5. DeltaConstantDelay2 shall ensure that it's properties are consistent 
%      with its current horizon_period property
%  6. DeltaConstantDelay2 shall be capable of changing it's properties to 
%      match a newly input horizon_period, as long as the new 
%      horizon_period is consistent with the prior horizon_period
%
%  7. DeltaConstantDelay2 shall be capable of generating a
%       MultiplierConstantDelay2 from a DeltaConstantDelay2 object

%%
%  Copyright (c) 2021 Massachusetts Institute of Technology 
%  SPDX-License-Identifier: GPL-2.0
%%

%% Test class for DeltaConstantDelay2 and MultiplierConstantDelay2
classdef testDeltaConstantDelay2 < matlab.unittest.TestCase
    
methods (TestMethodSetup)
function seedAndReportRng(testCase)
    seed = floor(posixtime(datetime('now')));
    rng(seed, 'twister');
    diagnose_str = ...
        sprintf(['Random inputs may be regenerated by calling: \n',...
                 '>> rng(%10d) \n',...
                 'before running the remainder of the test''s body'],...
                seed);
    testCase.onFailure(@() fprintf(diagnose_str));
end    
end
    
methods (Test)
function testFullConstructor(testCase)
    name = 'test';
    dim_outin = randi([1, 10]);
    delay_max = randi([1, 10]);
    horizon_period = [randi([0, 10]), randi([1, 10])];
    d = DeltaConstantDelay2(name, dim_outin, delay_max, horizon_period)
    total_time = sum(horizon_period);
    testCase.verifyEqual(d.name, name)
    testCase.verifyEqual(d.dim_out, repmat(dim_outin, 1, total_time))
    testCase.verifyEqual(d.dim_in,  repmat(dim_outin, 1, total_time))
    testCase.verifyEqual(d.delay_max, repmat(delay_max, 1, total_time))
    testCase.verifyEqual(d.horizon_period, horizon_period)
end

function testThreeArgConstructor(testCase)
    name = 'test';
    dim_outin = randi([1, 10]);
    delay_max = randi([1, 10]);
    d = DeltaConstantDelay2(name, dim_outin, delay_max);
    testCase.verifyEqual(d.name, name)
    testCase.verifyEqual(d.dim_out, dim_outin)
    testCase.verifyEqual(d.dim_in,  dim_outin)
    testCase.verifyEqual(d.delay_max, delay_max)
    testCase.verifyEqual(d.horizon_period, [0, 1])
end

function testTwoArgConstructor(testCase)
    name = 'test';
    dim_outin = randi([1, 10]);
    d = DeltaConstantDelay2(name, dim_outin);
    testCase.verifyEqual(d.name, name)
    testCase.verifyEqual(d.dim_out, dim_outin)
    testCase.verifyEqual(d.dim_in,  dim_outin)
    testCase.verifyEqual(d.delay_max, 1)
    testCase.verifyEqual(d.horizon_period, [0, 1])
end

function testOneArgConstructor(testCase)
    name = 'test';
    d = DeltaConstantDelay2(name);
    testCase.verifyEqual(d.name, name)
    testCase.verifyEqual(d.dim_out, 1)
    testCase.verifyEqual(d.dim_in,  1)
    testCase.verifyEqual(d.delay_max, 1)
    testCase.verifyEqual(d.horizon_period, [0, 1])
end

function testSamplingDelta(testCase)
    dim_outin = randi([1, 10]);
    delay_max = randi([1, 10]);
    d = DeltaConstantDelay2('test', dim_outin, delay_max);
    timestep = -1;
    d.validateSample(d.sample(timestep), timestep)
end

function testBadConstructorCalls(testCase)
    testCase.verifyError(@() DeltaConstantDelay2(),...
                         'DeltaConstantDelay2:DeltaConstantDelay2')
end

function testMultiplierConstruction(testCase)
    name = 'test';
    del = DeltaConstantDelay2(name);
    m = MultiplierConstantDelay2(del);
    testCase.verifyTrue(m.constraint_q11_kyp)

    constraint_q11_kyp = false;
    m = MultiplierConstantDelay2(del, 'constraint_q11_kyp', constraint_q11_kyp);
    testCase.verifyEqual(m.constraint_q11_kyp, constraint_q11_kyp)
end

function testDefaultConstructor(testCase)
    d = DeltaConstantDelay2('test');
    m = MultiplierConstantDelay2(d);

    % Standard property check
    verifyEqual(testCase, m.name,           d.name);
    verifyEqual(testCase, m.horizon_period, d.horizon_period)
    verifyEqual(testCase, m.delay_max,      d.delay_max);
    verifyEqual(testCase, m.dim_outin,      d.dim_out);

    % Check defaults
    verifyTrue(testCase, m.discrete)
    verifyTrue(testCase, m.constraint_q11_kyp)
    verifyEqual(testCase, m.basis_length, 2)
    verifyEqual(testCase, m.basis_poles, -0.5)
    verifyEqual(testCase, size(m.basis_function), [m.basis_length, 1])
    verifyEqual(testCase, size(m.basis_realization), [m.basis_length, 1])
    [~, U] = minreal(m.basis_realization);
    verifyEqual(testCase, U, eye(size(U, 1)));    
end

function testNoPoles(testCase)
    del = DeltaConstantDelay2('test');
    basis_length = 1;
    mult = MultiplierConstantDelay2(del, 'basis_length', basis_length);
    verifyEqual(testCase, mult.basis_length, basis_length)
    verifyEmpty(testCase, mult.basis_poles)
    
    basis_poles = [];
    mult = MultiplierConstantDelay2(del, 'basis_poles', basis_poles);
    verifyEqual(testCase, mult.basis_length, basis_length)
    verifyEmpty(testCase, mult.basis_poles)
end

function testLongBasisOneRealPole(testCase)
    del = DeltaConstantDelay2('test');
    basis_length = 5;
    basis_poles = 0.6;
    mult = MultiplierConstantDelay2(del,...
                          'basis_length', basis_length,...
                          'basis_poles', basis_poles);

    verifyEqual(testCase, mult.basis_length, basis_length)

    verifyEqual(testCase,...
                mult.basis_function(1,1),...
                tf(1, 1, mult.basis_function.Ts));
    verifyEqual(testCase, length(mult.basis_function), basis_length)
    basis_function_zpk = zpk(mult.basis_function);
    for i = 2:basis_length
        verifyLessThan(testCase,...
                       abs(basis_function_zpk.P{i}' - ...
                           repmat(basis_poles, 1, i - 1)),...
                       1e-4 * ones(i - 1, 1))                               
    end            
end

function testLongBasisManyRealPoles(testCase)
    del = DeltaConstantDelay2('test');
    basis_length = 5;
    basis_poles = linspace(-.9, .9, basis_length - 1)';
    mult = MultiplierConstantDelay2(del,...
                          'basis_length', basis_length,...
                          'basis_poles', basis_poles);

    verifyEqual(testCase, mult.basis_length, basis_length)

    verifyEqual(testCase,...
                mult.basis_function(1,1),...
                tf(1, 1, mult.basis_function.Ts));
    verifyEqual(testCase, length(mult.basis_function), basis_length)
    bf_zpk = zpk(mult.basis_function);
    for i = 2:basis_length
        verifyLessThan(testCase,...
                       abs(bf_zpk.P{i} - basis_poles(i - 1)), 1e-4)                               
    end            
end

function testLongBasisOneComplexPairPoles(testCase)
    del = DeltaConstantDelay2('test');
    basis_length = 5;
    basis_poles = [.5 + .5i, .5 - .5i];
    mult = MultiplierConstantDelay2(del,...
                          'basis_length', basis_length,...
                          'basis_poles', basis_poles);

    verifyEqual(testCase, mult.basis_length, basis_length)

    verifyEqual(testCase,...
                mult.basis_function(1,1),...
                tf(1, 1, mult.basis_function.Ts));
    verifyEqual(testCase, length(mult.basis_function), basis_length)
    bf_zpk = zpk(mult.basis_function);
    for i = 2:basis_length
        verifyLessThan(testCase,...
                       abs(cplxpair(bf_zpk.P{i}') - ...
                           cplxpair(repmat(basis_poles, 1, i - 1))),...
                       1e-3 * ones(i - 1, 1))                             
    end            
end

function testBasisPoleErrors(testCase)
    del = DeltaConstantDelay2('test');
    basis_length = 3;
    basis_poles = linspace(-.3,-.1,basis_length)';
    verifyError(testCase, ...
                @() MultiplierConstantDelay2(del,...
                                   'basis_length', basis_length,...
                                   'basis_poles', basis_poles),...
                ?MException,...
                ['Exception should be thrown for too many poles',...
                 'given the length (real poles, in discrete-time)'])

    basis_length = 5;
    verifyError(testCase, ...
                @() MultiplierConstantDelay2(del,...
                                   'basis_length', basis_length,...
                                   'basis_poles', basis_poles,...
                                   'discrete', false),...
                ?MException,...
                ['Exception should be thrown for too few poles',...
                 'given the length (real poles, in continuous-time)'])

    basis_length = 2;
    basis_poles = -1.2;
    verifyError(testCase, ...
                @() MultiplierConstantDelay2(del,...
                                   'basis_length', basis_length,...
                                   'basis_poles', basis_poles),...
                ?MException,...
                ['Exception should be thrown for unstable poles',...
                 '(real poles, in discrete-time)'])

    basis_poles = 1.2;
    verifyError(testCase, ...
                @() MultiplierConstantDelay2(del,...
                                   'basis_length', basis_length,...
                                   'basis_poles', basis_poles,...
                                   'discrete', false),...
                ?MException,...
                ['Exception should be thrown for unstable poles',...
                 '(real poles, in continuous-time)'])

    basis_poles = [-.5 + 1.2i, -.5 - 1.2i];
    verifyError(testCase, ...
                @() MultiplierConstantDelay2(del,...
                                   'basis_length', basis_length,...
                                   'basis_poles', basis_poles),...
                ?MException,...
                ['Exception should be thrown for unstable poles',...
                 '(complex poles, in discrete-time)'])

    basis_poles = [1.2i, -1.2i];
    verifyError(testCase, ...
                @() MultiplierConstantDelay2(del,...
                                   'basis_length', basis_length,...
                                   'basis_poles', basis_poles),...
                ?MException,...
                ['Exception should be thrown for unstable poles',...
                 '(complex poles, in continuous-time)'])

    basis_poles = [.5i, -.4i];
    verifyError(testCase, ...
                @() MultiplierConstantDelay2(del,...
                                   'basis_length', basis_length,...
                                   'basis_poles', basis_poles),...
                ?MException,...
                ['Exception should be thrown for non-conjugate',...
                 'pole pairs (in discrete-time)'])

    basis_poles = [-2 + .5i, -2 - .4i];
    verifyError(testCase, ...
                @() MultiplierConstantDelay2(del,...
                                   'basis_length', basis_length,...
                                   'basis_poles', basis_poles,...
                                   'discrete', false),...
                ?MException,...
                ['Exception should be thrown for non-conjugate',...
                 'pole pairs (in continuous-time)'])

end

function testSetBasisFunction(testCase)
    del = DeltaConstantDelay2('test');
    rng(10, 'twister')
    basis_ss = rss(4, 6, 1);
    basis_function = tf(basis_ss);
    while (~isstable(basis_function))
        basis_ss = rss(4, 6, 1);
        basis_function = tf(basis_ss);
    end            
    mult = MultiplierConstantDelay2(del,...
              'basis_function', basis_function,...
              'discrete', false);                  
    verifyEmpty(testCase,...
                mult.basis_length,...
                ['When independently setting basis_function, ',...
                 'basis_length should set empty (continuous-time)']);
    verifyEmpty(testCase,...
                mult.basis_poles,...
                ['When independently setting basis_function, ',...
                 'basis_poles should set empty (continuous-time)']);
    verifyEqual(testCase, mult.basis_function, basis_function)
    error_sys = lftToSs(mult.filter_lft) ...
                 - blkdiag([mult.basis_delay * basis_ss; basis_ss], basis_ss);
    verifyLessThan(testCase, norm(error_sys, 'inf'), 1e-3)

    basis_ss = drss(4, 6, 1);
    basis_function = tf(basis_ss);
    while (~isstable(basis_function))
        basis_ss = drss(4, 6, 1);
        basis_function = tf(basis_ss);
    end            
    mult = MultiplierConstantDelay2(del,...
              'basis_function', basis_function);                  
    verifyEmpty(testCase,...
                mult.basis_length,...
                ['When independently setting basis_function, ',...
                 'basis_length should set empty (discrete-time)']);
    verifyEmpty(testCase,...
                mult.basis_poles,...
                ['When independently setting basis_function, ',...
                 'basis_poles should set empty (discrete-time)']);
    verifyEqual(testCase, mult.basis_function, basis_function)
    error_sys = lftToSs(mult.filter_lft) ...
                 - blkdiag([mult.basis_delay * basis_ss; basis_ss], basis_ss);
    verifyLessThan(testCase, norm(error_sys, 'inf'), 1e-3)
end

function testBasisFunctionErrors(testCase)
    del = DeltaConstantDelay2('test');

    basis_function = tf(zpk([], 0.5, 1));
    verifyError(testCase,...
                @() MultiplierConstantDelay2(del,...
                                   'basis_function', basis_function,...
                                   'discrete', false),...
                ?MException,...
                ['Exception should be thrown for providing',...
                 ' unstable basis_function (continuous-time)'])

    basis_function = tf(zpk([], -1.1, 1, []));
    verifyError(testCase,...
                @()MultiplierConstantDelay2(del,...
                                  'basis_function', basis_function),...
                ?MException,...
                ['Exception should be thrown for providing',...
                 ' unstable basis_function (discrete-time)'])

    basis_function = tf(drss(randi(4), randi(4), 2));
    verifyError(testCase,...
                @()MultiplierConstantDelay2(del,...
                                  'basis_function', basis_function),...
                ?MException,...
                ['Exception should be thrown for providing a tf',...
                 'whose width is greater than 1'])

    basis_function = tf(drss(1));
    verifyError(testCase,...
                @()MultiplierConstantDelay2(del,...
                                  'basis_function', basis_function,...
                                  'discrete', false),...
                ?MException,...
                ['Exception should be thrown for providing a ',...
                 'discrete-time tf to a continuous-time multiplier'])

    basis_function = tf(rss(1));
    verifyError(testCase,...
                @()MultiplierConstantDelay2(del,...
                                  'basis_function', basis_function),...
                ?MException,...
                ['Exception should be thrown for providing a ',...
                 'continuous-time tf to a discrete-time multiplier'])                     
end

function testSetBasisRealization(testCase)
    del = DeltaConstantDelay2('test');

    basis_realization = rss(4, 6, 1);
    while (~isstable(basis_realization))
        basis_realization = rss(4, 6, 1);
    end            
    mult = MultiplierConstantDelay2(del,...
              'basis_realization', basis_realization,...
              'discrete', false);                  
    verifyEmpty(testCase,...
                mult.basis_length,...
                ['When independently setting basis_realization, ',...
                 'basis_length should set empty (continuous-time)']);
    verifyEmpty(testCase,...
                mult.basis_poles,...
                ['When independently setting basis_realization, ',...
                 'basis_poles should set empty (continuous-time)']);
    verifyEmpty(testCase,...
                mult.basis_function,...
                ['When independently setting basis_realization, ',...
                 'basis_function should set empty (continuous-time)']);

    verifyEqual(testCase, mult.basis_realization, basis_realization)

    basis_realization = drss(4, 6, 1);
    while (~isstable(basis_realization))
        basis_realization = drss(4, 6, 1);
    end            
    mult = MultiplierConstantDelay2(del,...
              'basis_realization', basis_realization);                  
    verifyEmpty(testCase,...
                mult.basis_length,...
                ['When independently setting basis_realization, ',...
                 'basis_length should set empty (discrete-time)']);
    verifyEmpty(testCase,...
                mult.basis_poles,...
                ['When independently setting basis_realization, ',...
                 'basis_poles should set empty (discrete-time)']);
    verifyEmpty(testCase,...
                mult.basis_function,...
                ['When independently setting basis_realization, ',...
                 'basis_function should set empty (discrete-time)']);

    verifyEqual(testCase, mult.basis_realization, basis_realization)
end        

function testBasisRealizationErrors(testCase)
    del = DeltaConstantDelay2('test');

    br = ss(0.5, 1, 1, 0);
    verifyError(testCase,...
                @() MultiplierConstantDelay2(del,...
                                   'basis_realization', br,...
                                   'discrete', false),...
                ?MException,...
                ['Exception should be thrown for providing',...
                 ' unstable basis_realization (continuous-time)'])

    br = ss(-1.2, 1, 1, 0, []);
    verifyError(testCase,...
                @()MultiplierConstantDelay2(del,...
                                  'basis_realization', br),...
                ?MException,...
                ['Exception should be thrown for providing',...
                 ' unstable basis_realization (discrete-time)'])

    br = drss(randi(4), randi(4), 2);
    verifyError(testCase,...
                @()MultiplierConstantDelay2(del,...
                                  'basis_realization', br),...
                ?MException,...
                ['Exception should be thrown for providing a tf',...
                 'whose width is greater than 1'])

    br = drss(1);
    verifyError(testCase,...
                @()MultiplierConstantDelay2(del,...
                                  'basis_realization', br,...
                                  'discrete', false),...
                ?MException,...
                ['Exception should be thrown for providing a ',...
                 'discrete-time tf to a continuous-time multiplier'])

    br = rss(1);
    verifyError(testCase,...
                @()MultiplierConstantDelay2(del,...
                                  'basis_realization', br),...
                ?MException,...
                ['Exception should be thrown for providing a ',...
                 'continuous-time tf to a discrete-time multiplier'])                      
end

function testShiftingMultiplier(testCase)
    del = DeltaConstantDelay2('test');
    % Correct shifting with specified exponential rate (discrete-time)
    expo = 0.6;
    m_discrete = MultiplierConstantDelay2(del, 'exponential', expo);
    filt = m_discrete.filter_lft;
    m_shifted = m_discrete.shiftMultiplier();
    filt_shifted = m_shifted.filter_lft;
    testCase.verifyEqual(filt_shifted.a{1}, filt.a{1} / expo);    
    testCase.verifyEqual(filt_shifted.b{1}, filt.b{1} / expo);
    testCase.verifyEqual(filt_shifted.c{1}, filt.c{1});
    testCase.verifyEqual(filt_shifted.d{1}, filt.d{1});
    % Correct shfiting with default exponential rate (no shift)
    m_discrete = MultiplierConstantDelay2(del);
    filt = m_discrete.filter_lft;
    m_shifted = m_discrete.shiftMultiplier();
    filt_shifted = m_shifted.filter_lft;
    testCase.verifyEqual(filt_shifted.a{1}, filt.a{1});    
    testCase.verifyEqual(filt_shifted.b{1}, filt.b{1});
    testCase.verifyEqual(filt_shifted.c{1}, filt.c{1});
    testCase.verifyEqual(filt_shifted.d{1}, filt.d{1});
    
    % Correct shifting with specified exponential rate (continuous-time)
    expo = 0.4;
    m_continuous = MultiplierConstantDelay2(del,...
                                            'exponential', expo,...
                                            'discrete', false);
    filt = m_continuous.filter_lft;
    m_shifted = m_continuous.shiftMultiplier();
    filt_shifted = m_shifted.filter_lft;
    testCase.verifyEqual(filt_shifted.a{1}, filt.a{1} + expo * eye(size(filt.a{1})));        
    testCase.verifyEqual(filt_shifted.b{1}, filt.b{1});
    testCase.verifyEqual(filt_shifted.c{1}, filt.c{1});
    testCase.verifyEqual(filt_shifted.d{1}, filt.d{1});
    % Correct shifting with default exponential rate (no shift)
    m_continuous = MultiplierConstantDelay2(del, 'discrete', false);
    filt = m_continuous.filter_lft;
    m_shifted = m_continuous.shiftMultiplier();
    filt_shifted = m_shifted.filter_lft;
    testCase.verifyEqual(filt_shifted.a{1}, filt.a{1});        
    testCase.verifyEqual(filt_shifted.b{1}, filt.b{1});
    testCase.verifyEqual(filt_shifted.c{1}, filt.c{1});
    testCase.verifyEqual(filt_shifted.d{1}, filt.d{1});
    
    % No shift when multiplier is memoryless
    del = DeltaSltv('test');
    expo = -1.5;
    m = MultiplierSltv(del);
    filt = m.filter_lft;
    m_shift = m.shiftMultiplier(expo);
    filt_shifted = m_shift.filter_lft;
    testCase.verifyEqual(filt_shifted.a{1}, filt.a{1});        
    testCase.verifyEqual(filt_shifted.b{1}, filt.b{1});
    testCase.verifyEqual(filt_shifted.c{1}, filt.c{1});
    testCase.verifyEqual(filt_shifted.d{1}, filt.d{1});
    
end
end
end

%%  CHANGELOG
% Apr. 18, 2022: Added after v0.9.0 - Micah Fry (micah.fry@ll.mit.edu)