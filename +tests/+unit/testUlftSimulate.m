%% Requirements:
%  1. Ulft.simulate shall take an input signal, and possible the intial state and timestamps of the input signal,
%       and return an output signal, the timestamps to that output signal, and possibly the state signal, 
%       all derived from simulating the system with the input signal, timestamps, and initial_state
%  2. Ulft.simulate shall allow simulation of continuous-time LTI, discrete-time LTI/LTV, and memoryless LTI/LTV systems
%  3. Ulft.simulate shall throw an error if provided an uncertain system
%  4. Ulft.simulate shall throw an error if provided an input signal and timestamps which are inconsistent
%      - For memoryless and discrete-time systems, timestamps need not be provided
%  5. Ulft.simulate shall throw an error if provided an input signal inconsistent with the LFT dimensions
%  6. Ulft.simulate shall throw an error if provided an initial state inconsistent with the LFT

%%
%  Copyright (c) 2021 Massachusetts Institute of Technology 
%  SPDX-License-Identifier: GPL-2.0
%%

%% Test class for Ulft.simulate
classdef testUlftSimulate < matlab.unittest.TestCase

methods (TestMethodSetup)
function seedAndReportRng(testCase)
    seed = floor(posixtime(datetime('now')));
    rng(seed, 'twister');
    diagnose_str = ...
        sprintf(['Random inputs may be regenerated by calling: \n',...
                 '>> rng(%10d) \n',...
                 'before running the remainder of the test''s body'],...
                seed);
    testCase.onFailure(@() fprintf(diagnose_str));
end    
end
    
methods (Test)
function testAllInputs(testCase)
    g = rss;
    lft = toLft(g);
    dim_in = size(lft, 2);
    total_time = 100;
    u = randn(dim_in, total_time);
    time_in = 0:total_time - 1;
    x0 = randn(lft.delta.deltas{1}.dim_out, 1);
    [output, time, state] = simulate(lft, u, time_in, x0);
    [out_true, time_true, state_true] = lsim(g, u, time_in, x0);
    max_out_diff = max(max(abs(output - out_true')));
    max_time_diff = max(max(abs(time - time_true')));
    max_state_diff = max(max(abs(state - state_true')));
    verifyLessThan(testCase, max_out_diff, 1e-3)
    verifyLessThan(testCase, max_time_diff, 1e-3)
    verifyLessThan(testCase, max_state_diff, 1e-3)
end

function testThreeInputs(testCase)
    g = rss;
    lft = toLft(g);
    dim_in = size(lft, 2);
    total_time = 100;
    u = randn(dim_in, total_time);
    time_in = 0:total_time - 1;
    [output, time, state] = simulate(lft, u, time_in);
    [out_true, time_true, state_true] = lsim(g, u, time_in);
    max_out_diff = max(max(abs(output - out_true')));
    max_time_diff = max(max(abs(time - time_true')));
    max_state_diff = max(max(abs(state - state_true')));
    verifyLessThan(testCase, max_out_diff, 1e-3)
    verifyLessThan(testCase, max_time_diff, 1e-3)
    verifyLessThan(testCase, max_state_diff, 1e-3)
end

function testTwoInputs(testCase)
    g = drss;
    lft = toLft(g);
    dim_in = size(lft, 2);
    total_time = 100;
    u = randn(dim_in, total_time);
    [output, time, state] = simulate(lft, u);
    [out_true, time_true, state_true] = lsim(g, u);
    max_out_diff = max(max(abs(output - out_true')));
    max_time_diff = max(max(abs(time - time_true')));
    max_state_diff = max(max(abs(state - state_true')));
    verifyLessThan(testCase, max_out_diff, 1e-3)
    verifyLessThan(testCase, max_time_diff, 1e-3)
    verifyLessThan(testCase, max_state_diff, 1e-3)
end

function testMemorylessLti(testCase)
    g = drss(0, 3, 2);
    lft = toLft(g.d);
    dim_in = size(lft, 2);
    total_time = 100;
    u = randn(dim_in, total_time);
    [output, time, state] = simulate(lft, u);
    [out_true, time_true] = lsim(g, u);
    max_out_diff = max(max(abs(output - out_true')));
    max_time_diff = max(max(abs(time - time_true')));
    verifyLessThan(testCase, max_out_diff, 1e-3)
    verifyLessThan(testCase, max_time_diff, 1e-3)
    verifyEmpty(testCase, state)
end

function testDiscreteLtvFromLti(testCase)
    g = drss;
    lft = toLft(g);
    lft = matchHorizonPeriod(lft, [3, 5]);
    dim_in = size(lft, 2);
    total_time = 100;
    u = randn(dim_in(1), total_time);
    [output, time, state] = simulate(lft, u);
    [out_true, time_true, state_true] = lsim(g, u);
    max_out_diff = max(max(abs(output - out_true')));
    max_time_diff = max(max(abs(time - time_true')));
    max_state_diff = max(max(abs(state - state_true')));
    verifyLessThan(testCase, max_out_diff, 1e-3)
    verifyLessThan(testCase, max_time_diff, 1e-3)
    verifyLessThan(testCase, max_state_diff, 1e-3)
end

function testMemorylessLtvFromLti(testCase)
    g = drss(0, 4, 6);
    lft = toLft(g.d);
    lft = matchHorizonPeriod(lft, [3, 5]);
    dim_in = size(lft, 2);
    total_time = 100;
    u = randn(dim_in(1), total_time);
    [output, time, state] = simulate(lft, u);
    [out_true, time_true] = lsim(g, u);
    max_out_diff = max(max(abs(output - out_true')));
    max_time_diff = max(max(abs(time - time_true')));
    verifyLessThan(testCase, max_out_diff, 1e-3)
    verifyLessThan(testCase, max_time_diff, 1e-3)
    verifyEmpty(testCase, state)
end

function testDiscreteLtvTimeVaryingDims(testCase)
    dim_state = [2, 4, 5, 1, 3];
    horizon_period = [2, 3];
    timestep = 0.5;
    del_z = DeltaDelayZ(dim_state, 0.5, horizon_period);
    lft = toLft(del_z);
    total_time = 100;
    horizon_period = [total_time - 1, 1];
    horizon_period = commonHorizonPeriod([lft.horizon_period; horizon_period]);
    time_indices = makeNewIndices(lft.horizon_period, horizon_period);
    time_indices = time_indices(1 : total_time);
    dim_in = size(lft, 2);
    dim_in = dim_in(time_indices);
    u = cell(1, total_time);
    x0 = randn(dim_state(1), 1);
    for i = 1:total_time
        u{1, i} = randn(dim_in(i), 1);
    end
    [output, time, state] = simulate(lft, u, [], x0);
    state_true = u;
    state_true(1, 2:end) = state_true(1, 1:end - 1);
    state_true{1, 1} = x0;
    out_true = state_true;
    time_true = (0: total_time - 1) * timestep;
    maxdiff = @(c1, c2) cellfun(@(v1, v2) max(abs(v1 - v2)), c1, c2);
    max_out_diff = max(maxdiff(output, out_true));
    max_time_diff = max(max(abs(time - time_true)));
    max_state_diff = max(maxdiff(state, state_true));
    verifyLessThan(testCase, max_out_diff, 1e-3)
    verifyLessThan(testCase, max_state_diff, 1e-3)
    verifyLessThan(testCase, max_time_diff, 1e-3)
end

function testMemorylessLtvTimeVaryingDims(testCase)
    dim_in = [2, 4, 5, 2, 3];
    dim_out = dim_in - 1;
    horizon_period = [2, 3];
    for i = 1:length(dim_in)
        d{i} = 2 * eye(dim_out(i), dim_in(i));
    end
    lft = toLft(d, horizon_period);
    total_time = 100;
    horizon_period = [total_time - 1, 1];
    horizon_period = commonHorizonPeriod([lft.horizon_period; horizon_period]);
    time_indices = makeNewIndices(lft.horizon_period, horizon_period);
    time_indices = time_indices(1 : total_time);
    u = cell(1, total_time);
    for i = 1:total_time
        u{1, i} = randn(dim_in(time_indices(i)), 1);
    end
    [output, time, state] = simulate(lft, u);
    out_true = cellfun(@(u) 2 * u(1 : end -1), u, 'UniformOutput', false);
    time_true = (0: total_time - 1);
    maxdiff = @(c1, c2) cellfun(@(v1, v2) max(abs(v1 - v2)), c1, c2);
    max_out_diff = max(maxdiff(output, out_true));
    max_time_diff = max(max(abs(time - time_true)));
    verifyLessThan(testCase, max_out_diff, 1e-3)
    verifyLessThan(testCase, max_time_diff, 1e-3)
    verifyEmpty(testCase, state)
end

function testBadTimeLength(testCase)
    g = drss;
    lft = toLft(g);
    dim_in = size(lft, 2);
    total_time = 100;
    u = randn(dim_in, total_time);
    verifyError(testCase, @() simulate(lft, u, 0:total_time), 'Ulft:simulate');
end

function testBadLft(testCase)
    lft = Ulft.random('num_deltas', 2);
    dim_in = size(lft, 2);
    total_time = 100;
    u = randn(dim_in(1), total_time);
    verifyError(testCase, @() simulate(lft, u), 'Ulft:simulate')
end

function testBadInput(testCase)
    g = drss;
    lft = toLft(g);
    verifyError(testCase, @() simulate(lft), 'Ulft:simulate')
    
    dim_in = size(lft, 2);
    total_time = 50 * 2;
    u_bad = randn(dim_in + 1, total_time);
    verifyError(testCase, @() simulate(lft, u_bad), ?MException)
    
    d = {eye(2), 1};
    lft = toLft(d, [0, 2]);
    u_good = repmat({ones(2, 1), 1}, 1, total_time / 2);
    simulate(lft, u_good);
    
    u_bad = u_good(2:end);
    verifyError(testCase, @() simulate(lft, u_bad), 'Ulft:simulate')
    
    u_bad = ones(1, total_time);
    verifyError(testCase, @() simulate(lft, u_bad), ?MException)
end
end
end

%%  CHANGELOG
% Sep. 28, 2021 (v0.6.0)
% Aug. 26, 2021 (v.0.5.0): Initial release - Micah Fry (micah.fry@ll.mit.edu)