%% Requirements:
%  1. DeltaSlti shall be defined by it's name, in/out dimensions, and
%      lower/upper bounds.
%  2. Upon construction, and when queried by user, it shall display the
%      information described in (1).
%
%  3. If dimension and/or bound information is not provided by the user, by
%      default the object shall be 1 x 1, with bounds [-1, 1].
%
%  4. If the user provides no name, or the name is not a string, DeltaSlti 
%      shall throw an exception
%  5. If the user provides an in/out dimension that is not a natural number
%      DeltaSlti shall throw an exception
%
%  6. The in/out dimensions of DeltaSlti shall be equal.
%  7. If the user provides a lower bound which is greater than the upper
%      bound, DeltaSlti shall throw an exception
%  8. If the user provides +/- inf for either of the bounds, DeltaSlti
%      shall throw an exception
%
%  9. DeltaSlti shall return the necessary mappings and DeltaSlti
%      object to be used for normalizing an LFT with a DeltaSlti
%      uncertainty.

%%
%  Copyright (c) 2021 Massachusetts Institute of Technology 
%  SPDX-License-Identifier: GPL-2.0
%%

%% Test class for DeltaSlti.
classdef testDeltaSlti < matlab.unittest.TestCase
    
    methods (TestMethodSetup)
    function seedAndReportRng(testCase)
        seed = floor(posixtime(datetime('now')));
        rng('default');
        rng(seed, 'twister');
        diagnose_str = ...
            sprintf(['Random inputs may be regenerated by calling: \n',...
                     '>> rng(%10d) \n',...
                     'before running the remainder of the test''s body'],...
                    seed);
        testCase.onFailure(@() fprintf(diagnose_str));
    end    
    end
    
    methods (Test)
    function testFullConstructor(testCase)
        name = 'test';
        dim_outin = 2;
        lower_bound = -5.0;
        upper_bound = 10.0;
        delta_slti = DeltaSlti(name, dim_outin, lower_bound, upper_bound);
        verifyEqual(testCase, delta_slti.name, name)
        verifyEqual(testCase, delta_slti.dim_in, dim_outin)
        verifyEqual(testCase, delta_slti.dim_out, dim_outin)
        verifyEqual(testCase, delta_slti.dim_in, delta_slti.dim_out)
        verifyEqual(testCase, delta_slti.lower_bound, lower_bound)
        verifyEqual(testCase, delta_slti.upper_bound, upper_bound)
    end

    function testOneArgConstructor(testCase)
        name = 'test';
        delta_slti = DeltaSlti(name);
        verifyEqual(testCase, delta_slti.name, name)
        verifyEqual(testCase, delta_slti.dim_in, 1)
        verifyEqual(testCase, delta_slti.dim_out, 1)
        verifyEqual(testCase, delta_slti.dim_in, delta_slti.dim_out)
        verifyEqual(testCase, delta_slti.lower_bound, -1.0)
        verifyEqual(testCase, delta_slti.upper_bound, 1.0)
    end

    function testTwoArgConstructor(testCase)
        name = 'test';
        dim_outin = 7;
        delta_slti = DeltaSlti(name, dim_outin);
        verifyEqual(testCase, delta_slti.name, name)
        verifyEqual(testCase, delta_slti.dim_in, dim_outin)
        verifyEqual(testCase, delta_slti.dim_out, dim_outin)
        verifyEqual(testCase, delta_slti.dim_in, delta_slti.dim_out)
        verifyEqual(testCase, delta_slti.lower_bound, -1.0)
        verifyEqual(testCase, delta_slti.upper_bound, 1.0)
    end

    function testFailedName(testCase)
        verifyError(testCase, @() DeltaSlti(), ?MException)
        verifyError(testCase, @() DeltaSlti(1), ?MException)
    end

    function testFailedDimension(testCase)
        verifyError(testCase, @() DeltaSlti('test', -2), ?MException)
        verifyError(testCase, @() DeltaSlti('test', 2.2), ?MException)
    end

    function testFailedBounds(testCase)
        verifyError(testCase, @() DeltaSlti('test', 1, 1.0, -1.0), ?MException)
        verifyError(testCase, @() DeltaSlti('test', 1, -inf, 1.0), ?MException)
        verifyError(testCase, @() DeltaSlti('test', 1, -1.0, inf), ?MException)
    end

    function testCorrectLowerBoundFromMatchHorizonPeriod(testCase)
    % This test is written in response to the hotfix-008 issue. After 
    % correcting the matchHorizonPeriod bug (where lower_bound failed to 
    % be reset), this test now passes.
    
    % Deterministic input that used to throw errors
    horizon_period_lft = [2, 3];
    horizon_period_del1 = [1, 1];
    total_time_lft = sum(horizon_period_lft);
    a = repmat({eye(2)}, 1, total_time_lft);
    b = repmat({ones(2, 1)}, 1, total_time_lft);
    c = repmat({ones(1, 2)}, 1, total_time_lft);
    d = repmat({1}, 1, total_time_lft);
    del1 = DeltaBounded('del1', 1, 1, 1, horizon_period_del1);
    del_slti = DeltaSlti('dslti');
    delta = SequenceDelta(del1, del_slti);
    try
        lft = Ulft(a, b, c, d, delta, 'horizon_period', horizon_period_lft);
        no_errors = true;
    catch
        no_errors = false;
    end
    verifyTrue(testCase, no_errors)
    
    % Random inputs that usually throw errors
    try
        for i = 1:100
            lft = Ulft.random('horizon_period', horizon_period_lft,...
                              'req_deltas',     {del1, 'DeltaSlti'});
        end
        no_errors = true;
    catch
        no_errors = false;
    end
    verifyTrue(testCase, no_errors)
    end
    
    function testMatchHorizonPeriodNoArgument(testCase)
    % This tests correctness of matchHorizonPeriod when given no argument
        d = DeltaSlti('d');
        horizon_period2 = [2, 3];
        d2 = d;
        d2.horizon_period = horizon_period2;
        d2 = d2.matchHorizonPeriod();
        total_time = sum(horizon_period2);
        verifyEqual(testCase, d2.dim_out, ones(1, total_time))
        verifyEqual(testCase, d2.dim_in, ones(1, total_time))
        verifyEqual(testCase, d2.lower_bound, -ones(1, total_time))
        verifyEqual(testCase, d2.upper_bound, ones(1, total_time))
        compareObjects(d, d2)
        
        horizon_period3 = [3, 6];
        d3 = d2;
        d3.horizon_period = horizon_period3;
        verifyError(testCase,...
                    @() d3.matchHorizonPeriod(),...
                    'DeltaSlti:matchHorizonPeriod')
    end
    
    function testNormalization(testCase)
        % 10 randomly generated LFTs
        for i = 1:10
            dim_outin = randi([1, 10]);
            upper_bound = 10 * rand;
            lower_bound = upper_bound - 20 * rand;
            width = upper_bound - lower_bound;
            del = DeltaSlti('test', dim_outin, lower_bound, upper_bound);
            lft = Ulft.random('num_deltas', 1, 'req_deltas', {del});
            lft_n = normalizeLft(lft);
            total_time = sum(lft.horizon_period);
            
            % Check correctness
            % delta
            expected_del = DeltaSlti('test', dim_outin, -1, 1);
            verifyEqual(testCase, lft_n.delta.deltas{1}, expected_del)
            % a, b, c, d (via sampling)
            for j = 1 :3
                kern = rand;
                del_samp = (lower_bound + width * kern) * eye(dim_outin);
                del_n_samp = (-1 + 2 * kern) * eye(dim_outin);
                for k = 1:total_time
                    lft_samp = lft.d{k} + lft.c{k} * del_samp * ...
                               inv(eye(dim_outin) - lft.a{k} * del_samp) * ...
                               lft.b{k};
                    lft_n_samp = lft_n.d{k} + lft_n.c{k} * del_n_samp * ...
                                 inv(eye(dim_outin) - lft_n.a{k} * del_n_samp) * ...
                                 lft_n.b{k};
                    verifyLessThan(testCase,...
                                   max(abs(lft_samp - lft_n_samp)),...
                                   1e-5)
                end
            end 
        end
    end
    
    end
end

%%  CHANGELOG
% Sep. 28, 2021 (v0.6.0)
% Aug. 26, 2021 (v.0.5.0): Initial release - Micah Fry (micah.fry@ll.mit.edu)