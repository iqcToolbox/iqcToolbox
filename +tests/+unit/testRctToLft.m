%% Requirements:
%   1. rctToLft shall convert uss, umat, ureal, and ultidyn objects to Ulft objects
%	2. rctToLft shall throw an error if provided an invalid object
%   3. rctToLft shall throw a warning (but not interrupt) if the output
%       Ulft must have normalized Deltas.

%%
%  Copyright (c) 2021 Massachusetts Institute of Technology 
%  SPDX-License-Identifier: GPL-2.0
%%

%% Test class for rctToLft
classdef testRctToLft < matlab.unittest.TestCase

properties (Constant)
    old_warning_state = warning('query')
end

methods (TestMethodSetup)
    function seedAndReportRng(testCase)
    seed = floor(posixtime(datetime('now')));
    rng(seed);
    diagnose_str = ...
        sprintf(['Random inputs may be regenerated by calling: \n',...
                 '>> rng(%10d) \n',...
                 'before running the remainder of the test''s body'],...
                seed);
    testCase.onFailure(@() fprintf(diagnose_str));
    % tests.unit.testRctToLft.old_warning_state = warning('query');
    warning('off', 'rctToLft:rctToLft')
    warning('off', 'toDelta:toDelta')
    end    
end

methods (TestMethodTeardown)
    function turnWarningBackAgain(testCase)
        warning(tests.unit.testRctToLft.old_warning_state)
    end
end
    
methods(Test)
function testRctToLftUmat(testCase)
% Umat parameters
p_nom = 0;
q_nom = 1;
r_nom = -2;
r_low_bnd = -6;
r_up_bnd  = -1;

p_rct = ureal('p', p_nom);
q_rct = ureal('q', q_nom);
r_rct = ureal('r', r_nom, 'Range', [r_low_bnd, r_up_bnd]);

% Nominal system
mat_nom = [1, 2;
           3, 4];
% Handle for making uncertain system
mat_pqr = @(p, q, r) [p * r + q, r;
                          0    , q];
% Make Umat
mat_rct = mat_nom + mat_pqr(p_rct, q_rct, r_rct);
% Make Ulft
mat_iqc = rctToLft(mat_rct);

% Correct output, but we'll verify via sampling instead
% dim_outin = 1;
% p_iqc = DeltaSlti('p', dim_outin, p_nom - 1, p_nom + 1);
% q_iqc = DeltaSlti('q', dim_outin, q_nom - 1, q_nom + 1);
% r_iqc = DeltaSlti('r', dim_outin, r_low_bnd, r_up_bnd);
% mat_expected = mat_nom + mat_pqr(p_iqc, q_iqc, r_iqc);

% Check correctness of sampled systems
normalized_sample = [-1, 0, 1];
p_iqc_sam = normalized_sample;
q_iqc_sam = normalized_sample;
r_iqc_sam = normalized_sample;
p_sample = [p_nom - 1, p_nom, p_nom + 1];
q_sample = [q_nom - 1, q_nom, q_nom + 1];
r_sample = [r_low_bnd, r_nom, r_up_bnd];
for i = 1:length(p_sample)
    samp_mat_true = usubs(mat_rct,...
                         'p', p_sample(i),...
                         'q', q_sample(i),...
                         'r', r_sample(i));
    p_delta = mat_iqc.delta.deltas{strcmp('pNormalized', mat_iqc.delta.names)};
    q_delta = mat_iqc.delta.deltas{strcmp('qNormalized', mat_iqc.delta.names)};
    r_delta = mat_iqc.delta.deltas{strcmp('rNormalized', mat_iqc.delta.names)};
    p_del = toLft(p_iqc_sam(i) * eye(p_delta.dim_out));
    q_del = toLft(q_iqc_sam(i) * eye(q_delta.dim_out));
    r_del = toLft(r_iqc_sam(i) * eye(r_delta.dim_out));
    samp_mat_iqc = sampleDeltas(mat_iqc,...
                                {'pNormalized', 'qNormalized', 'rNormalized'},...
                                {p_del,          q_del,       r_del});
    verifyEqual(testCase, samp_mat_iqc.d{1}, samp_mat_true);
end

end

function testRctToLftUss(testCase)
    % Uss parameters
    dim_in  = 3;
    dim_out = 1;
    p_rct = ultidyn('p');
    q_bnd = 3;
    q_rct = ultidyn('q', [dim_out, dim_in], 'Bound', q_bnd);
    
    % Make nominal system
    dim_state = 4;
    ss_nom = rss(dim_state, dim_out, dim_in);
    ss_nom.a = ss_nom.a  - 0.1 * eye(dim_state);
    % Handle for making uncertain system
    ss_pq = @(p, q) p * (ss_nom + q);
    % RCT object
    ss_rct = ss_pq(p_rct, q_rct);
    % Make Ulft
    ss_iqc = rctToLft(ss_rct);
    
    % Correct Ulft object, but will verify with sampling
%     p_iqc = DeltaDlti('p');
%     q_iqc = DeltaDlti('q', dim_out, dim_in, q_bnd);
%     ss_iqc_correct = ss_pq(p_iqc, q_iqc);
    
    % Check correctness of sampling
    for i = 1:10
        dim_state_p = randi([1, 5]);
        dim_state_q = randi([1, 5]);
        p_ss = rss(dim_state_p);
        p_ss.a = p_ss.a - 0.1 * eye(dim_state_p);
        q_ss = rss(dim_state_q, dim_out, dim_in);
        q_ss.a = q_ss.a - 0.1 * eye(dim_state_q);
        samp_ss_true = usubs(ss_rct, 'p', p_ss, 'q', q_ss);
        samp_ss = sampleDeltas(ss_iqc,...
                               {'pNormalized', 'qNormalized'},...
                               {toLft(p_ss),   toLft(q_ss / q_bnd) },...
                               'override', true);
        samp_ss = ss(samp_ss.a{1}, samp_ss.b{1}, samp_ss.c{1}, samp_ss.d{1});
        error_ss = norm(samp_ss_true - samp_ss, 'inf');
        verifyLessThan(testCase, error_ss, 1e-6)
    end
end

function testToUlftUrealUltidyn(testCase)
% Umat parameters
p_nom = 3;
q_nom = -2;
r_nom = 1;
r_low_bnd = 0.5;
r_up_bnd  = 1.5;

p_rct = ureal('p', p_nom);
q_rct = ureal('q', q_nom);
r_rct = ureal('r', r_nom, 'Range', [r_low_bnd, r_up_bnd]);

% Nominal system
a_nom = 0.5 * eye(2);
% Handle for making uncertain system
a_pqr = @(p, q, r) [p * r + q, r;
                          0    , q];
% Make umats
a_rct = a_nom + a_pqr(p_rct, q_rct, r_rct);
b_rct = umat([p_rct; 0]);
c_rct = umat([0, q_rct]);
d_rct = umat(r_rct);
v_rct = ultidyn('v');

ss_rct = v_rct * uss(a_rct, b_rct, c_rct, d_rct);
% Make Ulft
ss_iqc = rctToLft(ss_rct);

% Check correctness of sampled systems
normalized_sample = [-1, 0, 1];
p_iqc_sam = normalized_sample;
q_iqc_sam = normalized_sample;
r_iqc_sam = normalized_sample;
p_sample = [p_nom - 1, p_nom, p_nom + 1];
q_sample = [q_nom - 1, q_nom, q_nom + 1];
r_sample = [r_low_bnd, r_nom, r_up_bnd];
v_sample = ss(zpk([], -0.5, 0.5)) + 0.75;
v_sample = v_sample / norm(v_sample, 'inf');
for i = 1:length(p_sample)
    samp_ss_true = usubs(ss_rct,...
                         'p', p_sample(i),...
                         'q', q_sample(i),...
                         'r', r_sample(i),...
                         'v', v_sample);
    p_delta = ss_iqc.delta.deltas{strcmp('pNormalized', ss_iqc.delta.names)};
    q_delta = ss_iqc.delta.deltas{strcmp('qNormalized', ss_iqc.delta.names)};
    r_delta = ss_iqc.delta.deltas{strcmp('rNormalized', ss_iqc.delta.names)};
    p_del = toLft(p_iqc_sam(i) * eye(p_delta.dim_out));
    q_del = toLft(q_iqc_sam(i) * eye(q_delta.dim_out));
    r_del = toLft(r_iqc_sam(i) * eye(r_delta.dim_out));
    v_del = toLft(v_sample);
    samp_ss = sampleDeltas(ss_iqc,...
                            {'pNormalized', 'qNormalized',...
                             'rNormalized', 'vNormalized'},...
                            {p_del,          q_del,...
                             r_del,          v_del});
    samp_ss = ss(samp_ss.a{1}, samp_ss.b{1}, samp_ss.c{1}, samp_ss.d{1});
    error_ss = norm(samp_ss_true - samp_ss, 'inf');
    verifyLessThan(testCase, error_ss, 1e-6)
end
end

function testRctToLftUssDiscreteTime(testCase)
    % Uss parameters
    dim_in  = 3;
    dim_out = 1;
    p_rct = ultidyn('p');
    q_bnd = 3;
    q_rct = ultidyn('q', [dim_out, dim_in], 'Bound', q_bnd);
    
    % Make nominal system
    dim_state = 4;
    ss_nom = drss(dim_state, dim_out, dim_in);
    ss_nom.a = 0.9 * ss_nom.a;
    % Handle for making uncertain system
    ss_pq = @(p, q) p * (ss_nom + q);
    % RCT object
    ss_rct = ss_pq(p_rct, q_rct);
    % Make Ulft
    ss_iqc = rctToLft(ss_rct);
    
    % Correct Ulft object, but will verify with sampling
%     p_iqc = DeltaDlti('p');
%     q_iqc = DeltaDlti('q', dim_out, dim_in, q_bnd);
%     ss_iqc_correct = ss_pq(p_iqc, q_iqc);
    
    % Check correctness of sampling
    for i = 1:10
        dim_state_p = randi([1, 5]);
        dim_state_q = randi([1, 5]);
        p_ss = drss(dim_state_p);
        p_ss.a = 0.9 * p_ss.a;
        p_ss = p_ss / norm(p_ss, 'inf');
        q_ss = drss(dim_state_q, dim_out, dim_in);
        q_ss.a = 0.9 * q_ss.a;
        q_ss = q_ss / norm(q_ss, 'inf') * q_bnd;
        samp_ss_true = usubs(ss_rct, 'p', p_ss, 'q', q_ss);
        samp_ss = sampleDeltas(ss_iqc,...
                               {'pNormalized', 'qNormalized'},...
                               {toLft(p_ss),   toLft(q_ss / q_bnd)},...
                               'override', true);
        samp_ss = ss(samp_ss.a{1},samp_ss.b{1}, samp_ss.c{1}, samp_ss.d{1}, -1);
        error_ss = norm(samp_ss_true - samp_ss, 'inf');
        verifyLessThan(testCase, error_ss, 1e-6)
    end
end

function testToUlftUrealUltidynDiscreteTime(testCase)
% Umat parameters
p_nom = 3;
q_nom = -2;
r_nom = 1;
r_low_bnd = 0.5;
r_up_bnd  = 1.5;

p_rct = ureal('p', p_nom);
q_rct = ureal('q', q_nom);
r_rct = ureal('r', r_nom, 'Range', [r_low_bnd, r_up_bnd]);

% Nominal system
a_nom = 0.5 * eye(2);
% Handle for making uncertain system
a_pqr = @(p, q, r) [p * r + q, r;
                          0    , q];
% Make umats
a_rct = a_nom + a_pqr(p_rct, q_rct, r_rct);
b_rct = umat([p_rct; 0]);
c_rct = umat([0, q_rct]);
d_rct = umat(r_rct);
v_rct = ultidyn('v');

ss_rct = v_rct * ss(a_rct, b_rct, c_rct, d_rct, 1);
% Make Ulft
ss_iqc = rctToLft(ss_rct);

% Check correctness of sampled systems
normalized_sample = [-1, 0, 1];
p_iqc_sam = normalized_sample;
q_iqc_sam = normalized_sample;
r_iqc_sam = normalized_sample;
p_sample = [p_nom - 1, p_nom, p_nom + 1];
q_sample = [q_nom - 1, q_nom, q_nom + 1];
r_sample = [r_low_bnd, r_nom, r_up_bnd];
v_sample = ss(zpk([], -0.5, 0.5, 1)) + 0.75;
v_sample = v_sample / norm(v_sample, 'inf');
for i = 1:length(p_sample)
    samp_ss_true = usubs(ss_rct,...
                         'p', p_sample(i),...
                         'q', q_sample(i),...
                         'r', r_sample(i),...
                         'v', ss(v_sample));
    p_delta = ss_iqc.delta.deltas{strcmp('pNormalized', ss_iqc.delta.names)};
    q_delta = ss_iqc.delta.deltas{strcmp('qNormalized', ss_iqc.delta.names)};
    r_delta = ss_iqc.delta.deltas{strcmp('rNormalized', ss_iqc.delta.names)};
    p_del = toLft(p_iqc_sam(i) * eye(p_delta.dim_out));
    q_del = toLft(q_iqc_sam(i) * eye(q_delta.dim_out));
    r_del = toLft(r_iqc_sam(i) * eye(r_delta.dim_out));
    v_del = toLft(v_sample);
    samp_ss = sampleDeltas(ss_iqc,...
                            {'pNormalized', 'qNormalized',...
                             'rNormalized', 'vNormalized'},...
                            {p_del,          q_del,...
                             r_del,          v_del});
    samp_ss = ss(samp_ss.a{1}, samp_ss.b{1}, samp_ss.c{1}, samp_ss.d{1}, -1);
    error_ss = norm(samp_ss_true - samp_ss, 'inf');
    verifyLessThan(testCase, error_ss, 1e-6)
end
end

function testUssWithoutState(testCase)
% Umat parameters
p_nom = -3;
q_nom = 10;
r_nom = 0;
r_low_bnd = -3;
r_up_bnd  = 6;

p_rct = ureal('p', p_nom);
q_rct = ureal('q', q_nom);
r_rct = ureal('r', r_nom, 'Range', [r_low_bnd, r_up_bnd]);

% Nominal system
mat_nom = [1, 2;
           3, 4];
% Handle for making uncertain system
mat_pqr = @(p, q, r) [p * r + q, r;
                          0    , q];
% Make Umat
mat_rct = uss(mat_nom + mat_pqr(p_rct, q_rct, r_rct));
% Make Ulft
mat_iqc = rctToLft(mat_rct);

% Correct output, but we'll verify via sampling instead
% dim_outin = 1;
% p_iqc = DeltaSlti('p', dim_outin, p_nom - 1, p_nom + 1);
% q_iqc = DeltaSlti('q', dim_outin, q_nom - 1, q_nom + 1);
% r_iqc = DeltaSlti('r', dim_outin, r_low_bnd, r_up_bnd);
% mat_expected = mat_nom + mat_pqr(p_iqc, q_iqc, r_iqc);

% Check correctness of sampled systems
normalized_sample = [-1, 0, 1];
p_iqc_sam = normalized_sample;
q_iqc_sam = normalized_sample;
r_iqc_sam = normalized_sample;
p_sample = [p_nom - 1, p_nom, p_nom + 1];
q_sample = [q_nom - 1, q_nom, q_nom + 1];
r_sample = [r_low_bnd, r_nom, r_up_bnd];
for i = 1:length(p_sample)
    samp_mat_true = usubs(mat_rct,...
                         'p', p_sample(i),...
                         'q', q_sample(i),...
                         'r', r_sample(i));
    samp_mat_true = samp_mat_true.d;
    p_delta = mat_iqc.delta.deltas{strcmp('pNormalized', mat_iqc.delta.names)};
    q_delta = mat_iqc.delta.deltas{strcmp('qNormalized', mat_iqc.delta.names)};
    r_delta = mat_iqc.delta.deltas{strcmp('rNormalized', mat_iqc.delta.names)};
    p_del = toLft(p_iqc_sam(i) * eye(p_delta.dim_out));
    q_del = toLft(q_iqc_sam(i) * eye(q_delta.dim_out));
    r_del = toLft(r_iqc_sam(i) * eye(r_delta.dim_out));
    samp_mat_iqc = sampleDeltas(mat_iqc,...
                                {'pNormalized', 'qNormalized', 'rNormalized'},...
                                {p_del,          q_del,       r_del});
    verifyEqual(testCase, samp_mat_iqc.d{1}, samp_mat_true, 'AbsTol', 1e-4);
end

    
end

function testCheckWarnings(testCase)
    warning('on', 'rctToLft:rctToLft');
    warning('on', 'toDelta:toDelta');
    nonnormalized_unc = ureal('d1', 0) + ultidyn('d2');
    % No warning should throw here
    verifyWarningFree(testCase, @() rctToLft(nonnormalized_unc))

    normalized_unc = ureal('d1', 1) + ultidyn('d2', 1, 'Bound', 5);
    % Warning should be thrown here
    verifyWarning(testCase, @() rctToLft(normalized_unc), 'rctToLft:rctToLft')
    verifyWarning(testCase, @() toDelta(ureal('d1', 1)), 'toDelta:toDelta')
end

function testBadInputs(testCase)
    verifyError(testCase, @() rctToLft(udyn('dyn')), 'rctToLft:rctToLft')
    verifyError(testCase, @() rctToLft('a'), 'rctToLft:rctToLft')
    verifyError(testCase, @() rctToLft(1), 'rctToLft:rctToLft')
end

function testUltidyn(testCase)
    name = 'd';
    dim_out = 2;
    dim_in = 4;
    gain = 2;
    d_rct = ultidyn(name, [dim_out, dim_in], 'Bound', gain);
    lft_iqc = rctToLft(d_rct);
    lft_expected = toLft(DeltaDlti(name, dim_out, dim_in, gain));
    verifyEqual(testCase, lft_iqc, lft_expected)
end

function testUreal(testCase)
    % Simplest construction
    name = 'd';
    dim_outin = 1;
    nom_value = 3;
    lower_bound = -1;
    upper_bound = 4;
    d_rct = ureal(name, nom_value, 'Range', [lower_bound, upper_bound]);
    d_iqc = rctToLft(d_rct);
    d_expected = toLft(DeltaSlti(name, dim_outin, lower_bound, upper_bound));
    verifyEqual(testCase, d_iqc, d_expected)
end

end
    
end

%%  CHANGELOG
% Sep. 28, 2021 (v0.6.0): Added after v0.5.0 - Micah Fry (micah.fry@ll.mit.edu)