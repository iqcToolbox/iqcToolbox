%% Requirements:
%  1. DeltaBounded shall be defined by the its name, its in/out dimensions
%      the upper bound on its l2-induced norm, and its horizon_period.
%  2. Upon construction, and when queried by user, it shall display the
%      information described in (1).
%
%  3. The default in/out dimensions shall be 1 x 1, the default upper bound
%      shall be 1, and the default horizon_period shall be [0, 1].
%
%  4. If the user provides no name, or the name is not a string,
%      DeltaBounded shall throw an exception
%  5. If the user provides in/out dimensions that are not natural
%      numbers DeltaBounded shall throw an exception
%  6. If the user provides a negative, inf, or nan value for the upper bound, 
%      DeltaBounded shall throw an exception
%
%  7. DeltaBounded shall ensure that upper bounds provided by users are 
%      constant
%  8. DeltaBounded shall be capable of ensuring that the properties 
%      dim_out, dim_in, and upper_bound are consistent with its current 
%      horizon_period property
%  9. DeltaBounded shall be capable of changing it's properties to match a
%      newly input horizon_period, as long as the new horizon_period is
%      consistent with the prior horizon_period
%  10.DeltaBounded shall ensure that properties which the user describes as
%      constant will be consistent with the user-provided horizon period
%  11.If the user provides time-varying properties that are inconsistent
%      with the horizon_period, DeltaBounded shall throw an exception
%
%  12.DeltaBounded shall be capable of returning an appropriate multiplier.
%
%  13.DeltaBounded shall return the necessary mappings and DeltaBounded
%      object to be used for normalizing an LFT with a DeltaBounded
%      uncertainty.

%%
%  Copyright (c) 2021 Massachusetts Institute of Technology 
%  SPDX-License-Identifier: GPL-2.0
%%

%% Test class for DeltaBounded.
classdef testDeltaBounded < matlab.unittest.TestCase
    
methods (TestMethodSetup)
    function seedAndReportRng(testCase)
        seed = floor(posixtime(datetime('now')));
        rng('default');
        rng(seed, 'twister');
        diagnose_str = ...
            sprintf(['Random inputs may be regenerated by calling: \n',...
                     '>> rng(%10d) \n',...
                     'before running the remainder of the test''s body'],...
                    seed);
        testCase.onFailure(@() fprintf(diagnose_str));
    end    
end

methods (Test)
function testFullConstructor(testCase)
    name = 'test';
    dim_out = [3, 2, 1, 1];
    dim_in = 2;
    upper_bound = 10.0;
    horizon_period = [2, 2];
    delta_bnd = DeltaBounded(name,...
                             dim_out,...
                             dim_in,...
                             upper_bound,...
                             horizon_period);
    verifyEqual(testCase, delta_bnd.name, name)
    verifyEqual(testCase,...
                delta_bnd.dim_in,...
                dim_in * ones(1, sum(horizon_period)))
    verifyEqual(testCase, delta_bnd.dim_out, dim_out)
    verifyEqual(testCase,...
                delta_bnd.upper_bound,...
                upper_bound * ones(1, sum(horizon_period)))
    verifyEqual(testCase, delta_bnd.horizon_period, horizon_period)
end

function testOneArgConstructor(testCase)
    name = 'test';
    delta_bnd = DeltaBounded(name);
    verifyEqual(testCase, delta_bnd.name, name)
    verifyEqual(testCase, delta_bnd.dim_in, 1)
    verifyEqual(testCase, delta_bnd.dim_out, 1)
    verifyEqual(testCase, delta_bnd.upper_bound, 1.0)
    verifyEqual(testCase, delta_bnd.horizon_period, [0, 1])
end

function testThreeArgConstructor(testCase)
    name = 'test';
    dim_out = 7;
    dim_in = 3;
    delta_bnd = DeltaBounded(name, dim_out, dim_in);
    verifyEqual(testCase, delta_bnd.name, name)
    verifyEqual(testCase, delta_bnd.dim_out, dim_out)
    verifyEqual(testCase, delta_bnd.dim_in, dim_in)
    verifyEqual(testCase, delta_bnd.upper_bound, 1.0)
end

function testDeltaToMultiplier(testCase)
    name = 'test';
    delta_bnd = DeltaBounded(name);
    try
        default_mult = deltaToMultiplier(delta_bnd);
        no_error = true;
    catch
        no_error = false;
    end
    verifyTrue(testCase, no_error)
end

function testHorizonPeriod(testCase)
   name = 'test';
   delta_bnd = DeltaBounded(name);
   assertEqual(testCase, delta_bnd.horizon_period, [0, 1])
   
   % Resetting horizon_period and making sure it fits for all properties
   horizon_period2 = [4, 7];
   delta_bnd.horizon_period = horizon_period2;
   total_time2 = sum(horizon_period2);
   assertNotEqual(testCase, length(delta_bnd.dim_out), total_time2)
   assertNotEqual(testCase, length(delta_bnd.dim_in), total_time2)
   assertNotEqual(testCase, length(delta_bnd.upper_bound), total_time2)
   delta_bnd = matchHorizonPeriod(delta_bnd);
   verifyEqual(testCase, delta_bnd.horizon_period, horizon_period2)
   verifyEqual(testCase, length(delta_bnd.dim_out), total_time2)
   verifyEqual(testCase, length(delta_bnd.dim_in), total_time2)
   verifyEqual(testCase, length(delta_bnd.upper_bound), total_time2)
   
   % Resetting horizon_period and making sure it fits for all properties
   horizon_period3 = [3, 2];
   total_time3 = sum(horizon_period3);
   assertNotEqual(testCase, length(delta_bnd.dim_out), total_time3)
   assertNotEqual(testCase, length(delta_bnd.dim_in), total_time3)
   assertNotEqual(testCase, length(delta_bnd.upper_bound), total_time3)
   delta_bnd = matchHorizonPeriod(DeltaBounded(name), horizon_period3);
   verifyEqual(testCase, delta_bnd.horizon_period, horizon_period3)   
   verifyEqual(testCase, length(delta_bnd.dim_out), total_time3)
   verifyEqual(testCase, length(delta_bnd.dim_in), total_time3)
   verifyEqual(testCase, length(delta_bnd.upper_bound), total_time3)
end

function testFailedHorizonPeriod(testCase)
   name = 'test';
   delta_bnd = DeltaBounded(name);
   assertEqual(testCase, delta_bnd.horizon_period, [0, 1])
   
   % Resetting horizon_period and making sure it fits for all properties
   horizon_period2 = [2, 1];
   total_time2 = sum(horizon_period2);
   delta_bnd.horizon_period = horizon_period2;
   delta_bnd = matchHorizonPeriod(delta_bnd);
   assertEqual(testCase, delta_bnd.horizon_period, horizon_period2)   
   assertEqual(testCase, length(delta_bnd.dim_out), total_time2)
   assertEqual(testCase, length(delta_bnd.dim_in), total_time2)
   assertEqual(testCase, length(delta_bnd.upper_bound), total_time2)
   
   % Resetting horizon_period and incorrectly trying to force a fit with
   % other properties
   horizon_period3 = [5, 3];
   horizon_period3 = commonHorizonPeriod([horizon_period2; horizon_period3]);
   delta_bnd.horizon_period = horizon_period3;
   verifyError(testCase, @() matchHorizonPeriod(delta_bnd), ?MException)
end

function testFailedHorizonPeriodConstructor(testCase)
    name = 'test';
    dim_in = [1, 1];
    verifyError(testCase, @() DeltaBounded(name, 1, dim_in), ?MException);
    bnd = [1, 2, 3];
    hp = [0, 2];
    verifyError(testCase, @() DeltaBounded(name, 1, 1, bnd, hp), ?MException);
end

function testFailedName(testCase)
    verifyError(testCase, @() DeltaBounded(), ?MException)
    verifyError(testCase, @() DeltaBounded(1), ?MException)
end

function testFailedDimension(testCase)
    verifyError(testCase, @() DeltaBounded('test', -2), ?MException)
    verifyError(testCase, @() DeltaBounded('test', 2.2), ?MException)
end

function testFailedBounds(testCase)
    verifyError(testCase, @() DeltaBounded('test', 1, 1, -0.1), ?MException)
    verifyError(testCase, @() DeltaBounded('test', 1, 1, inf), ?MException)
    verifyError(testCase, @() DeltaBounded('test', 1, 1, nan), ?MException)
    verifyError(testCase, @() DeltaBounded('test', 1, 1, []), ?MException)
end

function testFailedConstantBounds(testCase)
    name = 'test';
    dim_out = [1, 1, 1];
    dim_in = [1, 1, 1];
    bnd = [2, 3, 1];
    hp = [1, 2];
    verifyError(testCase,...
                @() DeltaBounded(name, dim_out, dim_in, bnd, hp),...
                ?MException)
end

function testDisplay(testCase)
    try
        delta_bnd = DeltaBounded('test')
        no_error = true;
    catch
        no_error = false;
    end
    verifyTrue(testCase, no_error)
end

function testNormalization(testCase)
    for i = 1:10
        % Create original and normalized LFTs
        hor_per = [randi([0, 10]), randi([1, 10])];
        total_time = sum(hor_per);
        dim_out = randi([1, 10]);
        dim_in = randi([1, 10]);
        upper_bound = 10 * rand;
        del = DeltaBounded('test',dim_out, dim_in, upper_bound, hor_per);
        lft = Ulft.random('num_deltas', 1, 'req_deltas', {del});
        lft_n = normalizeLft(lft);
        
        for j = 1:total_time
            expected_a = lft.a{j} * upper_bound;
            verifyLessThan(testCase, max(abs(lft_n.a{j} - expected_a)), 1e-5)
            
            expected_b = lft.b{j} * upper_bound;
            verifyLessThan(testCase, max(abs(lft_n.b{j} - expected_b)), 1e-5)
        end
        expected_delta = DeltaBounded('test', dim_out, dim_in, 1, hor_per);
        verifyEqual(testCase, lft_n.delta.deltas{1}, expected_delta);
    end
end
end
end

%%  CHANGELOG
% Sep. 28, 2021 (v0.6.0)
% Aug. 26, 2021 (v.0.5.0): Initial release - Micah Fry (micah.fry@ll.mit.edu)