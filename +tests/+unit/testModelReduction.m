%% Requirements:
% 1: modelReduction shall take an LFT with repeated Deltas and return an LFT with reduced repititions 
% 2: modelReduction shall take a stable LFT and conduct model reduction via balanced truncation of that LFT.
% 3: If the given LFT is stable, modelReduction shall report a correct upper bound on the error between the truncated and original LFTs
% 4: modelReduction shall take an unstable but stabilizable LFT, and conduct model reduction via coprime factors reduction.
% 5: If the given LFT is unstable but stabilizable, modelReduction shall indicate that the returned error bound is not a
%     bound on the error between the truncated and the original system
% 6: modelReduction shall throw an error if given an unstabilizable LFT or an LFT with inadmissible Deltas


%%
%  Copyright (c) 2021 Massachusetts Institute of Technology 
%  SPDX-License-Identifier: GPL-2.0
%%

%% Test class for ModelReduction
classdef testModelReduction < matlab.unittest.TestCase
    
methods (TestMethodSetup)
    function seedAndReportRng(testCase)
        seed = floor(posixtime(datetime('now')));
        rng('default')
        rng(seed);
        diagnose_str = ...
            sprintf(['Random inputs may be regenerated by calling: \n',...
                     '>> rng(%10d) \n',...
                     'before running the remainder of the test''s body'],...
                    seed);
        testCase.onFailure(@() fprintf(diagnose_str));
    end    
end

methods (Test)
    
function testSimpleDelayZ(testCase)
    options = AnalysisOptions('verbose', false);
    % Does this balance correctly?
    lft_big = [DeltaDelayZ(); DeltaDelayZ()];
    error_red = 1e-8;
    lft_bal = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big - lft_bal, 'analysis_options', options);
    assertTrue(testCase, result.valid)
    acceptable_error = 1e-2;
    verifyLessThan(testCase, result.performance, acceptable_error)

    % Does this reduce correctly?
    error_red = 1e-2;
    lft_red = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big - lft_red, 'analysis_options', options);
    assertTrue(testCase, result.valid)
    verifyLessThan(testCase, result.performance, acceptable_error)
    verifyEqual(testCase, lft_red.delta.dim_outs, 1)
end

function testSimpleDelayZSubtraction(testCase)
    options = AnalysisOptions('verbose', false);
    % Does this balance correctly?
    lft_big = DeltaDelayZ() - DeltaDelayZ();
    error_red = 1e-8;
    lft_bal = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big - lft_bal, 'analysis_options', options);
    assertTrue(testCase, result.valid)
    acceptable_error = 1e-2;
    verifyLessThan(testCase, result.performance, acceptable_error)

    % Does this reduce correctly?
    error_red = 1e-2;
    lft_red = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big - lft_red, 'analysis_options', options);
    assertTrue(testCase, result.valid)
    verifyLessThan(testCase, result.performance, acceptable_error)
    verifyEmpty(testCase, lft_red.delta.deltas)
end

function testSimpleDeltaSlti(testCase)
    options = AnalysisOptions('verbose', false);
    % Does this balance correctly?
    lft_big = [DeltaSlti('a'); DeltaSlti('a')];
    error_red = 1e-8;
    lft_bal = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big*DeltaDelayZ() - lft_bal*DeltaDelayZ(),...
                         'analysis_options', options);
    assertTrue(testCase, result.valid)
    acceptable_error = 1e-2;
    verifyLessThan(testCase, result.performance, acceptable_error)

    % Does this reduce correctly?
    error_red = 1e-2;
    lft_red = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big*DeltaDelayZ() - lft_red*DeltaDelayZ(),...
                         'analysis_options', options);
    assertTrue(testCase, result.valid)
    verifyLessThan(testCase, result.performance, acceptable_error)
    verifyEqual(testCase, lft_red.delta.dim_outs, 1)
end

function testSimpleDeltaSltiSubtraction(testCase)
    options = AnalysisOptions('verbose', false);
    % Does this balance correctly?
    lft_big = DeltaSlti('a') - DeltaSlti('a');
    error_red = 1e-8;
    lft_bal = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big*DeltaDelayZ() - lft_bal*DeltaDelayZ(),...
                         'analysis_options', options);
    assertTrue(testCase, result.valid)
    acceptable_error = 1e-2;
    verifyLessThan(testCase, result.performance, acceptable_error)

    % Does this reduce correctly?
    error_red = 1e-2;
    lft_red = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big*DeltaDelayZ() - lft_red*DeltaDelayZ(),...
                         'analysis_options', options);
    assertTrue(testCase, result.valid)
    verifyLessThan(testCase, result.performance, acceptable_error)
    verifyEmpty(testCase, lft_red.delta.deltas)
end

function testComboDeltaDelayZAndSlti(testCase)
    options = AnalysisOptions('verbose', false);
    % Does this balance correctly?
    lft_big = [DeltaDelayZ() * DeltaSlti('a');
               DeltaDelayZ() * DeltaSlti('a')];
    error_red = 1e-8;
    lft_bal = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big - lft_bal, 'analysis_options', options);
    assertTrue(testCase, result.valid)
    acceptable_error = 1e-2;
    verifyLessThan(testCase, result.performance, acceptable_error)

    % Does this reduce correctly?
    error_red = 1e-2;
    lft_red = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big - lft_red, 'analysis_options', options);
    assertTrue(testCase, result.valid)
    verifyLessThan(testCase, result.performance, acceptable_error)
    verifyEqual(testCase, lft_red.delta.dim_outs, [1; 1])
end

function testComboDeltaDelayZAndSltiSubtraction(testCase)
    options = AnalysisOptions('verbose', false);
    % Does this balance correctly?
    z = DeltaDelayZ();
    slti = DeltaSlti('a');
    lft_big = (z * slti) - (z * slti);
    error_red = 1e-8;
    lft_bal = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big - lft_bal, 'analysis_options', options);
    assertTrue(testCase, result.valid)
    acceptable_error = 1e-2;
    verifyLessThan(testCase, result.performance, acceptable_error)

    % Does this reduce correctly?
    error_red = 1e-2;
    lft_red = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big - lft_red, 'analysis_options', options);
    assertTrue(testCase, result.valid)
    verifyLessThan(testCase, result.performance, acceptable_error)
    verifyEqual(testCase, lft_red.delta.dim_outs, [])
end

function testRandomZAndSltv(testCase)
    rng(1629200974)
    options = AnalysisOptions('verbose', false, 'lmi_shift', 1e-6);
    error_bal = 1e-8;
    error_red = 1e-2;
    error_red2 = 0.025;
    acceptable_error = 1e-1;
    for i = 1:1
        dim_state = 1;
        dim_in = 1;
        dim_out = 1;
        z = DeltaDelayZ(dim_state);
        a_del = DeltaSlti('a', dim_state);
        b_del = Ulft.random('req_deltas', {z},...
                            'num_delta', 1,...
                            'dim_out', dim_out,...
                            'dim_in', dim_in,...
                            'horizon_period', [0, 1]);
        b_del.delta.deltas{1} = DeltaSltv('b', dim_state, -.5, .5);
        result = iqcAnalysis(b_del * z, 'analysis_options', options);
        scale = 1;
        b_del = toLft(b_del) * (scale / result.performance * eye(dim_in));
        lft_seed = Ulft.random('req_deltas', {z},...
                               'num_delta', 1,...
                               'dim_out', dim_out,...
                               'dim_in', dim_in,...
                               'horizon_period', [0, 1]);
        a_lft = lft_seed.a{1} * a_del;
        b_lft = b_del; %lft_seed.b{1};%
        c_lft = lft_seed.c{1};
        d_lft = lft_seed.d{1};
        
        lft_atom = toLft(a_lft, b_lft, c_lft, d_lft, -1);
        lft_big1 = [lft_atom, lft_atom];
        % Check balancing for horzcat
        lft_bal1 = modelReduction(lft_big1, error_bal);
        result = iqcAnalysis(normalizeLft(lft_big1) - lft_bal1, 'analysis_options', options);
        assertTrue(testCase, result.valid)
        verifyLessThan(testCase, result.performance, acceptable_error)
        % Check reduction for horzcat
        lft_red1 = modelReduction(lft_big1, error_red);
        result = iqcAnalysis(normalizeLft(lft_big1) - lft_red1, 'analysis_options', options);
        assertTrue(testCase, result.valid)
        verifyLessThan(testCase, result.performance, acceptable_error)
        verifyEqual(testCase,...
                    lft_red1.delta.dim_outs,...
                    lft_atom.delta.dim_outs)

        lft_big2 = lft_atom - lft_atom;
        % Check balancing for subtraction
        lft_bal2 = modelReduction(lft_big2, error_bal);
        result = iqcAnalysis(normalizeLft(lft_big2) - lft_bal2, 'analysis_options', options);
        assertTrue(testCase, result.valid)
        verifyLessThan(testCase, result.performance, acceptable_error)
        % Check reduction for subtraction
        lft_red2 = modelReduction(lft_big2, error_red2);
        result = iqcAnalysis(normalizeLft(lft_big2) - lft_red2, 'analysis_options', options);
        assertTrue(testCase, result.valid)
        verifyLessThan(testCase, result.performance, acceptable_error)
        verifyEmpty(testCase,...
                    lft_red2.delta.dim_outs)
    end
end

function testComboDeltaDelayZAndSltiLtv(testCase)
    options = AnalysisOptions('verbose', false, 'lmi_shift', 1e-6);
    % Does this balance correctly?
    lft_big = [DeltaDelayZ() * DeltaSlti('a');
               DeltaDelayZ() * DeltaSlti('a')];
    lft_big = matchHorizonPeriod(lft_big, [3, 1]);
    error_red = 1e-8;
    lft_bal = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big - lft_bal, 'analysis_options', options);
    assertTrue(testCase, result.valid)
    acceptable_error = 1e-2;
    verifyLessThan(testCase, result.performance, acceptable_error)

    % Does this reduce correctly?
    error_red = 1e-2;
    lft_red = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big - lft_red, 'analysis_options', options);
    assertTrue(testCase, result.valid)
    verifyLessThan(testCase, result.performance, acceptable_error)
    verifyEqual(testCase, lft_red.delta.dim_outs, [0 1 1 1; 1 1 1 1])
end

function testSimpleDelayZHP(testCase)
    options = AnalysisOptions('verbose', false);
    % Does this balance correctly?
    lft_big = [DeltaDelayZ(); DeltaDelayZ()];
    lft_big = matchHorizonPeriod(lft_big, [3, 5]);
    error_red = 1e-8;
    lft_bal = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big - lft_bal, 'analysis_options', options);
    assertTrue(testCase, result.valid)
    acceptable_error = 1e-2;
    verifyLessThan(testCase, result.performance, acceptable_error)

    % Does this reduce correctly?
    error_red = 1e-2;
    lft_red = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big - lft_red, 'analysis_options', options);
    assertTrue(testCase, result.valid)
    verifyLessThan(testCase, result.performance, acceptable_error)
    verifyEqual(testCase, lft_red.delta.dim_outs, [0, ones(1,7)])
end

function testRandomZHP(testCase)
    rng(1629979943) 
    options = AnalysisOptions('verbose', false);
    % Does this balance correctly?
    del_z = DeltaDelayZ(2);
    lft_atom = Ulft.random('req_deltas', {del_z},...
                           'num_delta', 1,...
                           'horizon_period', [3, 2]);
    result = iqcAnalysis(lft_atom, 'analysis_options', options);
    dim_in = size(lft_atom, 2);
    scale = 100;
    lft_atom = lft_atom * (scale / result.performance * eye(dim_in(1)));
    lft_big = [lft_atom; lft_atom];
    error_red = 1e-8;
    lft_bal = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_bal - lft_big, 'analysis_options', options);
    assertTrue(testCase, result.valid)
    acceptable_error = 1e-2;
    verifyLessThan(testCase, result.performance, acceptable_error)
    
    % Does this reduce correctly?
    error_red = 1e-1;
    lft_red = modelReduction(lft_big, error_red);
    result = iqcAnalysis(lft_big - lft_red, 'analysis_options', options);
    assertTrue(testCase, result.valid)
    verifyLessThan(testCase, result.performance, acceptable_error)
    verifyEqual(testCase, lft_red.delta.dim_outs, [0, 2 * ones(1, 4)])
end

function testUnstableLtiState(testCase)
    g = ss(zpk([], [-1.2], 1, -1));
    lft_atom = toLft(g);
    % Does this balance correctly?
    lft_big = [lft_atom, lft_atom];
    lft_true = toLft(g) * [1, 1];
    error_red = 1e-8;
    lft_bal = modelReduction(lft_big, error_red);
    y_true = step(lftToRct(lft_true));
    y_bal  = step(lftToRct(lft_bal));
    sig_diff = @tests.unit.testModelReduction.signal_difference;
    diff1 = sig_diff(y_true(:, 1, 1), y_bal(:, 1, 1));
    diff2 = sig_diff(y_true(:, 1, 2), y_bal(:, 1, 2));
    acceptable_error = 1e-2;
    verifyLessThan(testCase, max(diff1, diff2), acceptable_error)
    
    % Does this reduce correctly?
    error_red = 2 * 1.3;
    lft_red = modelReduction(lft_big, error_red);
    y_red  = step(lftToSs(lft_red));
    sig_diff = @tests.unit.testModelReduction.signal_difference;
    diff1 = sig_diff(y_true(:, 1, 1), y_red(:, 1, 1));
    diff2 = sig_diff(y_true(:, 1, 2), y_red(:, 1, 2));
    acceptable_error = 1e-2;
    verifyLessThan(testCase, max(diff1, diff2), acceptable_error)
    verifyEqual(testCase, lft_red.delta.dim_outs, lft_true.delta.dim_outs)

end

function testUnstableLtiStateAndUncs(testCase)
    g = ss(zpk([], [-1.2], 1, -1));
    lft_atom = toLft(g) + DeltaSlti('d');
    % Does this balance correctly?
    lft_big = [lft_atom, lft_atom];
    lft_true = (toLft(g) + DeltaSlti('d')) * [1, 1];
    error_red = 1e-8;
    lft_bal = modelReduction(lft_big, error_red);
    y_true = step(lftToRct(lft_true));
    y_bal  = step(lftToRct(lft_bal));
    sig_diff = @tests.unit.testModelReduction.signal_difference;
    diff1 = sig_diff(y_true(:, 1, 1), y_bal(:, 1, 1));
    diff2 = sig_diff(y_true(:, 1, 2), y_bal(:, 1, 2));
    acceptable_error = 1e-2;
    verifyLessThan(testCase, max(diff1, diff2), acceptable_error)
    
    % Does this reduce correctly?
    error_red = 2 * 1.4;
    lft_red = modelReduction(lft_big, error_red);
    y_red  = step(lftToRct(lft_red));
    sig_diff = @tests.unit.testModelReduction.signal_difference;
    diff1 = sig_diff(y_true(:, 1, 1), y_red(:, 1, 1));
    diff2 = sig_diff(y_true(:, 1, 2), y_red(:, 1, 2));
    acceptable_error = 1e-2;
    verifyLessThan(testCase, max(diff1, diff2), acceptable_error)
    verifyEqual(testCase, lft_red.delta.dim_outs, lft_true.delta.dim_outs)
end

function testUnstableLtvStateAndUncs(testCase)
    g = ss(zpk([], [-1.2], 1, -1));
    lft_atom = toLft(g) + DeltaSltv('d');
    lft_atom = matchHorizonPeriod(lft_atom, [2, 3]);
    % Does this balance correctly?
    lft_big = [lft_atom, lft_atom];
    lft_true = (toLft(g) + DeltaSltv('d')) * [1, 1];
    lft_true = matchHorizonPeriod(lft_true, [2, 3]);
    error_red = 2 * 1.5;
    lft_red = modelReduction(lft_big, error_red);
    expected_dims = [0, ones(1, 4); ones(1, 5)];
    verifyEqual(testCase, lft_red.delta.dim_outs, expected_dims)
    % Need check on model correctness via sampling and simulation
end
% 
% function testUnstableRandom(testCase)
%     del_z = DeltaDelayZ(2);
%     lft_atom = Ulft.random('req_deltas', {del_z},...
%                            'num_delta', 1,...
%                            'horizon_period', [0, 1],...
%                            'dim_in', 1,...
%                            'dim_out', 1);
%     lft_atom.a{1} = lft_atom.a{1} * 1.2 / max(abs(eig(lft_atom.a{1})));
%     % Does this balance correctly?
%     lft_big = [lft_atom; lft_atom];
% end
end

methods (Static)
    function u_diff = signal_difference(u_true, u_approx)
        rel_diff = (u_true - u_approx) ./ u_true;
        abs_diff = abs(u_true - u_approx);
        u_diff = max(min(rel_diff, abs_diff)); 
    end
end
end
        
%%  CHANGELOG
% Sep. 28, 2021 (v0.6.0): Added after v0.5.0 - Micah Fry (micah.fry@ll.mit.edu)