%% Requirements:
%  1. DeltaSltvRepeated shall be defined by the names of each uncertainty,
%      the number of repetitions of each uncertainty, the type of region in
%      which the uncertainties reside, a specification of that region, and
%      the horizon_period.
%  2. Upon construction, and when queried by user, it shall display the
%      information described in (1).
%
%  3. The admissible region types of DeltaSltvRepeated shall be a box, a
%      polytope described by vertices of the polytope, or a origin-centered
%      axes-symmetric ellipse.
%  4. If repetitions, region type, or region specification is not provided 
%      by the user, by default the object shall one repetition of each 
%      uncertainty, with the vector of uncertainties inside a unit-box,
%      with a horizon_period [0, 1].
%
%  5. If the user provides no name, or the name is not a string or cell of 
%      strings, DeltaSltvRepeated shall throw an exception
%  6. If the user provides an in/out dimensions that are not natural
%      numbers DeltaSltvRepeated shall throw an exception
%  7. If the user provides inadmissible specifications of the uncertainty 
%      region, DeltaSltvRepeated shall throw an exception
%  8. For a box region, if the user provides a lower bound which is greater
%      than the upper bound, DeltaSltvRepeated shall throw an exception
%  9. For a polytope region, if the convex hull of the vertices does not 
%      contain the origin, DeltaSltvRepeated shall throw an exception
%  10.For an ellipse region, if the radii are not well-defined,
%      DeltaSltvRepeated shall throw an exception
%
%  11.The in/out dimensions of DeltaSltvRepeated shall be equal.
%
%  12.DeltaSltvRepeated shall ensure that it's properties are consistent 
%      with its current horizon_period property
%  13.DeltaSltv shall be capable of changing it's properties to match a
%      newly input horizon_period, as long as the new horizon_period is
%      consistent with the prior horizon_period
%
%  14.DeltaSltvRepeated shall return the necessary mappings and
%      DeltaSltvRepeated object to be used for normalizing an LFT with a 
%      DeltaSltvRepeated uncertainty.

%%
%  Copyright (c) 2021 Massachusetts Institute of Technology 
%  SPDX-License-Identifier: GPL-2.0
%%

%% Test class for DeltaSltvRepeated.
classdef testDeltaSltvRepeated < matlab.unittest.TestCase

methods (TestMethodSetup)
function seedAndReportRng(testCase)
    seed = floor(posixtime(datetime('now')));
    rng('default');
    rng(seed, 'twister');
    diagnose_str = ...
        sprintf(['Random inputs may be regenerated by calling: \n',...
                 '>> rng(%10d) \n',...
                 'before running the remainder of the test''s body'],...
                seed);
    testCase.onFailure(@() fprintf(diagnose_str));
end    
end
    
methods (Test)

function testFullBoxConstructor(testCase)
    names = {'x'; 'y'; 'z'};
    dim_outins = [2; 3; 1];
    region_type = 'box';
    lower_bounds = [-5.0; 1; -1];
    upper_bounds = [-3; 2; 1];
    region_data = {[lower_bounds, upper_bounds]};
    horizon_period = [0, 1];
    del = DeltaSltvRepeated(names,...
                            dim_outins,...
                            region_type,...
                            region_data,...
                            horizon_period);
    verifyEqual(testCase, del.name, strjoin(names, ', '))
    verifyEqual(testCase, del.dim_in, sum(dim_outins))
    verifyEqual(testCase, del.dim_out, sum(dim_outins))
    verifyEqual(testCase, del.dim_in, del.dim_out)
    verifyEqual(testCase, del.horizon_period, horizon_period)
    verifyEqual(testCase, del.names, names)
    verifyEqual(testCase, del.region_type, region_type)
    verifyEqual(testCase, del.region_data, region_data)
    verifyEqual(testCase, del.lower_bounds, {lower_bounds})
    verifyEqual(testCase, del.upper_bounds, {upper_bounds})
end

function testFullEllipseConstructor(testCase)
    names = {'x'; 'y'; 'z'};
    dim_outins = [2; 3; 1];
    region_type = 'ellipse';
    axes = [1; 2; 3];
    region_data = {axes};
    horizon_period = [3, 2];
    total_time = sum(horizon_period);
    del = DeltaSltvRepeated(names,...
                            dim_outins,...
                            region_type,...
                            region_data,...
                            horizon_period);
    verifyEqual(testCase, del.name, strjoin(names, ', '))
    verifyEqual(testCase, del.dim_in, repmat(sum(dim_outins), 1, total_time))
    verifyEqual(testCase, del.dim_out, repmat(sum(dim_outins), 1, total_time))
    verifyEqual(testCase, del.dim_in, del.dim_out)
    verifyEqual(testCase, del.horizon_period, horizon_period)
    verifyEqual(testCase, del.names, names)
    verifyEqual(testCase, del.region_type, region_type)
    verifyEqual(testCase, del.region_data, repmat(region_data, 1, total_time))
    verifyEqual(testCase, del.ellipses, repmat({axes}, 1, total_time))
end

function testFullPolytopeConstructor(testCase)
    names = {'x'; 'y'; 'z'};
    dim_outins = [1; 1; 5];
    region_type = 'polytope';
    vertices = [ 1,  1,  1,  1, -1, -1, -1, -1;
                 1,  1, -1, -1,  1,  1, -1, -1;
                 1, -1,  1, -1,  1, -1,  1, -1;];
    horizon_period = [5, 1];
    total_time = sum(horizon_period);
    del = DeltaSltvRepeated(names,...
                            dim_outins,...
                            region_type,...
                            {vertices},...
                            horizon_period);
    verifyEqual(testCase, del.name, strjoin(names, ', '))
    verifyEqual(testCase, del.dim_in, repmat(sum(dim_outins), 1, total_time))
    verifyEqual(testCase, del.dim_out, repmat(sum(dim_outins), 1, total_time))
    verifyEqual(testCase, del.dim_in, del.dim_out)
    verifyEqual(testCase, del.horizon_period, horizon_period)
    verifyEqual(testCase, del.names, names)
    verifyEqual(testCase, del.region_type, region_type)
    verifyEqual(testCase, del.region_data, repmat({vertices}, 1, total_time))
    verifyEqual(testCase, del.vertices, repmat({vertices}, 1, total_time))
end

function testOneArgConstructor(testCase)
    name = 'test';
    del = DeltaSltvRepeated(name);
    verifyEqual(testCase, del.name, name)
    verifyEqual(testCase, del.dim_in, 1)
    verifyEqual(testCase, del.dim_out, 1)
    verifyEqual(testCase, del.dim_in, del.dim_out)
    verifyEqual(testCase, del.horizon_period, [0, 1])
    verifyEqual(testCase, del.names, {name})
    verifyEqual(testCase, del.region_type, 'box')
    verifyEqual(testCase, del.region_data, {[-1, 1]})
    verifyEqual(testCase, del.lower_bounds, {-1.0})
    verifyEqual(testCase, del.upper_bounds, {1.0})
    
end

function testTwoArgConstructor(testCase)
    name = 'test';
    dim_outins = 7;
    del = DeltaSltvRepeated(name, dim_outins);
    verifyEqual(testCase, del.name, name)
    verifyEqual(testCase, del.dim_in, dim_outins)
    verifyEqual(testCase, del.dim_out, dim_outins)
    verifyEqual(testCase, del.dim_in, del.dim_out)
    verifyEqual(testCase, del.horizon_period, [0, 1])
    verifyEqual(testCase, del.names, {name})
    verifyEqual(testCase, del.region_type, 'box')
    verifyEqual(testCase, del.region_data, {[-1, 1]})
    verifyEqual(testCase, del.lower_bounds, {-1.0})
    verifyEqual(testCase, del.upper_bounds, {1.0})
end

function testFourArgConstructor(testCase)
    name = 'test';
    dim_outins = 7;
    region_type = 'box';
    upper_bound = 4.5;
    lower_bound = -0.1;
    region_data = {[lower_bound, upper_bound]};
    del = DeltaSltvRepeated(name, dim_outins, region_type, region_data);
    verifyEqual(testCase, del.name, name)
    verifyEqual(testCase, del.dim_in, dim_outins)
    verifyEqual(testCase, del.dim_out, dim_outins)
    verifyEqual(testCase, del.dim_in, del.dim_out)
    verifyEqual(testCase, del.horizon_period, [0, 1])
    verifyEqual(testCase, del.names, {name})
    verifyEqual(testCase, del.region_type, 'box')
    verifyEqual(testCase, del.region_data, region_data)
    verifyEqual(testCase, del.lower_bounds, {lower_bound})
    verifyEqual(testCase, del.upper_bounds, {upper_bound})
end

% function testDeltaToMultiplier(testCase)
%     name = 'test';
%     delta_sltv = DeltaSltv(name);
%     default_mult = deltaToMultiplier(delta_sltv);
%     verifyEqual(testCase, default_mult.quad_time_varying, true)
%     
%     quad_time_varying = false;
%     mult = deltaToMultiplier(delta_sltv,...
%                              'quad_time_varying',...
%                              quad_time_varying);
%     verifyEqual(testCase, mult.quad_time_varying, quad_time_varying)
% end

function testFailedName(testCase)
    verifyError(testCase, @() DeltaSltvRepeated(), ?MException)
    verifyError(testCase, @() DeltaSltvRepeated(1), ?MException)
    verifyError(testCase, @() DeltaSltvRepeated('x, y, z'), ?MException)
end

function testFailedDimension(testCase)
    verifyError(testCase, @() DeltaSltvRepeated('test', -2), ?MException)
    verifyError(testCase, @() DeltaSltvRepeated('test', 2.2), ?MException)
end

function testFailedBox(testCase)
    hp = [2, 2];
    total_time = sum(hp);
    lb = -1.2 * ones(1,total_time);
    ub = linspace(4, 5, total_time);
    lb(total_time) = ub(total_time) + 1;
    region_type = 'box';
    region_data = mat2cell([lb', ub'], ones(1, total_time), 2)';
    verifyError(testCase,...
                @() DeltaSltvRepeated('x', 1, region_type, region_data, hp),...
                ?MException)

    region_data{total_time}(1) = -inf;
    verifyError(testCase,...
                @() DeltaSltvRepeated('x', 1, region_type, region_data, hp),...
                ?MException)

    region_data{total_time}(1) = ub(total_time) - 1;
    region_data{total_time}(2) = nan;
    verifyError(testCase,...
                @()DeltaSltvRepeated('x', 1, region_type, region_data, hp),...
                ?MException)
end

function testFailedEllipse(testCase)
    names = {'x', 'y'};
    hp = [1, 3];
    total_time = sum(hp);
    dim_outins = [ones(1, total_time); 2 * ones(1, total_time)];
    region_type = 'ellipse';
    region_data = mat2cell([ones(1, total_time); 3 * ones(1, total_time)],...
                           2,...
                           ones(1, total_time));
    region_data{end}(1) = 0;
    verifyError(testCase,...
                @()DeltaSltvRepeated(names,...
                                     dim_outins,...
                                     region_type,...
                                     region_data,...
                                     hp),...
                ?MException)
    
    region_data{end} = [1; NaN];
    verifyError(testCase,...
                @()DeltaSltvRepeated(names,...
                                     dim_outins,...
                                     region_type,...
                                     region_data,...
                                     hp),...
                ?MException)
            
    region_data{end} = [inf; 2];
    verifyError(testCase,...
                @()DeltaSltvRepeated(names,...
                                     dim_outins,...
                                     region_type,...
                                     region_data,...
                                     hp),...
                ?MException)    
end

function testFailedPolytope(testCase)
    names = {'x', 'y'};
    dim_outins = [1; 1];
    region_type = 'polytope';
    region_data = repmat({[1, 1, -1, -1; 3, 1,  3,  1]}, 1, 2);
    hp = [1, 1];
    verifyError(testCase,...
                @()DeltaSltvRepeated(names,...
                                     dim_outins,...
                                     region_type,...
                                     region_data,...
                                     hp),...
                ?MException)
end    

function testHorizonPeriod(testCase)
   name = {'x'; 'y'};
   del = DeltaSltvRepeated(name);
   assertEqual(testCase, del.horizon_period, [0, 1])
   
   % Checking horizon_period and making sure it fits for all properties
   hp2 = [4, 3];
   total_time2 = sum(hp2);
   region_type = 'polytope';
   bnd = linspace(1, 2, total_time2);
   for i = 1:total_time2
       region_data{i} = [[-bnd(i); -bnd(i)], [bnd(i); bnd(i)]];
   end
   dim_outin2 = [1; 3];
   del = DeltaSltvRepeated(name, dim_outin2, region_type, region_data, hp2);
   del = matchHorizonPeriod(del);
   assertEqual(testCase, del.horizon_period, hp2)
   assertEqual(testCase, del.vertices, region_data)
   assertEqual(testCase, del.dim_in, repmat(sum(dim_outin2), 1, total_time2))
   assertEqual(testCase, del.dim_out, repmat(sum(dim_outin2), 1, total_time2))
   assertEqual(testCase, del.dim_outins, repmat(dim_outin2, 1, total_time2))

   % Resetting horizon_period and making sure it fits for all properties
   horizon_period3 = [total_time2, hp2(2) * 2];
   total_time3 = sum(horizon_period3);
   del = matchHorizonPeriod(del, horizon_period3);
   verifyEqual(testCase, del.horizon_period, horizon_period3)
   verifyEqual(testCase,...
               del.vertices,...
               [region_data,...
                region_data((1:(horizon_period3(2) / 2)) + hp2(1)),...
                region_data((1:(horizon_period3(2) / 2)) + hp2(1))])
   verifyEqual(testCase, del.dim_in,  repmat(sum(dim_outin2), 1, total_time3))
   verifyEqual(testCase, del.dim_out, repmat(sum(dim_outin2), 1, total_time3))
end

function testFailedHorizonPeriod(testCase)
   name = 'test';
   delta_sltv = DeltaSltv(name);
   assertEqual(testCase, delta_sltv.horizon_period, [0, 1])

   % Resetting horizon_period and making sure it fits for all properties
   horizon_period2 = [4, 7];
   delta_sltv.horizon_period = horizon_period2;
   delta_sltv = matchHorizonPeriod(delta_sltv);
   assertEqual(testCase, delta_sltv.horizon_period, horizon_period2)

   % Resetting horizon_period and incorrectly trying to force a fit with
   % other properties
   horizon_period3 = [5, 3];
   horizon_period3 = commonHorizonPeriod([horizon_period2; horizon_period3]);
   delta_sltv.horizon_period = horizon_period3;
   verifyError(testCase, @() matchHorizonPeriod(delta_sltv), ?MException)
end

function testNormalizationBox(testCase)
    % 10 randomly generated LFTs
    for i = 1:10
        num_dels = randi([1, 4]);
        names = cellfun(@num2str, num2cell(1:num_dels), 'UniformOutput', false);
        dim_outins = randi([1, 10], num_dels, 1);
        hp = [randi([0, 10]), randi([1, 10])];
        total_time = sum(hp);
        region_data = cell(1, total_time);
        width = cell(1, total_time);
        for j = 1:total_time
            upper_bound = 10 * rand(num_dels, 1);
            lower_bound = upper_bound - 20 * rand(num_dels, 1);
            region_data{j} = [lower_bound, upper_bound];
            width{j} = upper_bound - lower_bound;
        end
        del = DeltaSltvRepeated(names, dim_outins, 'box', region_data, hp);
        m = MultiplierSltvRepeated(del);
        verifyEqual(testCase, del.lower_bounds, m.lower_bounds)
        lft = Ulft.random('num_deltas', 1,...
                          'req_deltas', {del},...
                          'horizon_period', hp);
        lft_n = normalizeLft(lft);
        
        % Check correctness
        % delta
        exp_region = repmat({[-ones(num_dels, 1), ones(num_dels, 1)]},...
                                      1,...
                                      total_time);
        exp_del = DeltaSltvRepeated(names, dim_outins, 'box', exp_region, hp);
        verifyEqual(testCase, lft_n.delta.deltas{1}, exp_del)
        % a, b, c, d (via sampling)
        for j = 1:3
            kern = rand;
            for k = 1:total_time
                del_samp = num2cell(region_data{k}(:, 1) + width{k} * kern);
                del_samp = cellfun(@(del, blk) del * eye(blk),...
                                   del_samp',...
                                   num2cell(dim_outins)',...
                                   'UniformOutput', false);
                del_samp = blkdiag(del_samp{:});
                del_n_samp = (-1 + 2 * kern) * eye(del.dim_out(k));
                lft_samp = lft.d{k} + lft.c{k} * del_samp * ...
                           inv(eye(del.dim_out(k)) - lft.a{k} * del_samp) * ...
                           lft.b{k};
                lft_n_samp = lft_n.d{k} + lft_n.c{k} * del_n_samp * ...
                             inv(eye(del.dim_out(k)) - lft_n.a{k} * del_n_samp)* ...
                             lft_n.b{k};
                verifyLessThan(testCase,...
                               max(abs(lft_samp - lft_n_samp)),...
                               1e-4)
            end
        end
    end
end

function testNormalizationPolytope(testCase)
    points = {[-1, -1, 1, 1;
               -1,  1,-1, 1]};
    dim_outins = randi([1,5], 2, 1);
    hp = [randi([0, 10]), randi([1, 10])];
    del = DeltaSltvRepeated({'1', '2'}, dim_outins, 'polytope', points, hp);
    lft = Ulft.random('num_deltas', 1,...
                      'req_deltas', {del},...
                      'horizon_period', hp);
    warning_state = warning;
    warning('error', 'DeltaSltvRepeated:normalizeDelta')
    verifyError(testCase, @() normalizeLft(lft), ?MException)
    warning(warning_state);
    normalizeLft(lft);
end

function testEllipseBad(testCase)
    axes = {[2; 0.1]};
    dim_outins = randi([1, 5], 2, 1);
    hp = [randi([0, 10]), randi([1, 10])];
    del = DeltaSltvRepeated({'1', '2'}, dim_outins, 'ellipse', axes, hp);
    lft = Ulft.random('num_deltas', 1,...
                      'req_deltas', {del},...
                      'horizon_period', hp);
    warning_state = warning;
    warning('error', 'DeltaSltvRepeated:normalizeDelta')
    verifyError(testCase, @() normalizeLft(lft), ?MException)
    warning(warning_state);
    verifyError(testCase,...
                @() MultiplierSltvRepeated(del),...
                'MultiplierSltvRepeated:MultiplierSltvRepeated')
end

end
end

%%  CHANGELOG
% Sep. 28, 2021 (v0.6.0)
% Aug. 26, 2021 (v.0.5.0): Initial release - Micah Fry (micah.fry@ll.mit.edu)