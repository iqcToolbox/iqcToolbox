%% Requirements:
%  1. DeltaSltvRateBnd shall be defined by it's name, in/out dimensions, 
%      lower/upper bounds, lower/upper rates, and horizon_period.
%  2. Upon construction, and when queried by user, it shall display the
%      information described in (1).
%
%  3. If dimension and/or bound information is not provided by the user, by
%      default the object shall be 1x1, with bounds [-1, 1], rates [-2, 2],
%      and horizon_period [0, 1].
%
%  4. If the user provides no name, or the name is not a string, 
%      DeltaSltvRateBnd shall throw an exception
%  5. If the user provides an in/out dimension that is not a natural number
%      DeltaSltvRateBnd shall throw an exception
%
%  6. The in/out dimensions of DeltaSltvRateBnd shall be equal.
%  7. If the user provides a lower bound which is greater than the upper
%      bound, DeltaSltvRateBnd shall throw an exception
%  8. If the user provides a lower bound which is greater than the upper
%      bound, DeltaSltvRateBnd shall throw an exception
%  9. If the user provides +/- inf or Nan for either the bounds or rates, 
%      DeltaSltvRateBnd shall throw an exception
%
%  9. DeltaSltvRateBnd shall ensure that it's properties are consistent 
%      with its current horizon_period property
%  10.DeltaSltvRateBnd shall be capable of changing it's properties to 
%      match a newly input horizon_period, as long as the new 
%      horizon_period is consistent with the prior horizon_period
%
%  11.DeltaSltvRateBnd shall return the necessary mappings and DeltaSltvRateBnd
%      object to be used for normalizing an LFT with a DeltaSltvRateBnd
%      uncertainty.

%%
%  Copyright (c) 2021 Massachusetts Institute of Technology 
%  SPDX-License-Identifier: GPL-2.0
%%

%% Test class for DeltaSltvRateBnd.
classdef testDeltaSltvRateBnd < matlab.unittest.TestCase
    
methods (TestMethodSetup)
function seedAndReportRng(testCase)
    seed = floor(posixtime(datetime('now')));
    rng('default');
    rng(seed, 'twister');
    diagnose_str = ...
        sprintf(['Random inputs may be regenerated by calling: \n',...
                 '>> rng(%10d) \n',...
                 'before running the remainder of the test''s body'],...
                seed);
    testCase.onFailure(@() fprintf(diagnose_str));
end    
end
    
methods (Test)

function testFullConstructor(testCase)
    name = 'test';
    dim_outin = 2;
    lower_bound = -5.0;
    upper_bound = 10.0;
    lower_rate  = -3.3;
    upper_rate  = 2.0;
    horizon_period = [0, 1];
    del = DeltaSltvRateBnd(name,...
                           dim_outin,...
                           lower_bound,...
                           upper_bound,...
                           lower_rate,...
                           upper_rate,...
                           horizon_period);
    verifyEqual(testCase, del.name, name)
    verifyEqual(testCase, del.dim_in, dim_outin)
    verifyEqual(testCase, del.dim_out, dim_outin)
    verifyEqual(testCase, del.dim_in, del.dim_out)
    verifyEqual(testCase, del.lower_bound, lower_bound)
    verifyEqual(testCase, del.upper_bound, upper_bound)
    verifyEqual(testCase, del.lower_rate, lower_rate)
    verifyEqual(testCase, del.upper_rate, upper_rate)
    verifyEqual(testCase, del.horizon_period, horizon_period)
end

function testFullConstructorDifferentHorizonPeriod(testCase)
    name = 'test';
    dim_outin = 2;
    lower_bound = -5.0;
    upper_bound = [10.0, 7, 8, 9, 9];
    lower_rate  = [-1, -2, -4,-1,-2];
    upper_rate  = 1.3;
    horizon_period = [3, 2];
    total_time = sum(horizon_period);
    del = DeltaSltvRateBnd(name,...
                           dim_outin,...
                           lower_bound,...
                           upper_bound,...
                           lower_rate,...
                           upper_rate,...
                           horizon_period);
    verifyEqual(testCase, del.name, name)
    verifyEqual(testCase,...
                del.dim_in,...
                dim_outin * ones(1, total_time))
    verifyEqual(testCase,...
                del.dim_out,...
                dim_outin * ones(1, total_time))
    verifyEqual(testCase, del.dim_in, del.dim_out)
    verifyEqual(testCase,...
                del.lower_bound,...
                lower_bound * ones(1, total_time))
    verifyEqual(testCase, del.upper_bound, upper_bound)
    verifyEqual(testCase, del.lower_rate, lower_rate)
    verifyEqual(testCase,...
                del.upper_rate,...
                upper_rate * ones(1, total_time))
    
    verifyEqual(testCase, del.horizon_period, horizon_period)
end

function testOneArgConstructor(testCase)
    name = 'test';
    del = DeltaSltvRateBnd(name);
    verifyEqual(testCase, del.name, name)
    verifyEqual(testCase, del.dim_in, 1)
    verifyEqual(testCase, del.dim_out, 1)
    verifyEqual(testCase, del.dim_in, del.dim_out)
    verifyEqual(testCase, del.lower_bound, -1.0)
    verifyEqual(testCase, del.upper_bound, 1.0)
    verifyEqual(testCase, del.lower_rate, -2.0)
    verifyEqual(testCase, del.upper_rate, 2.0)
    verifyEqual(testCase, del.horizon_period, [0, 1])
end

function testTwoArgConstructor(testCase)
    name = 'test';
    dim_outin = 7;
    del = DeltaSltvRateBnd(name, dim_outin);
    verifyEqual(testCase, del.name, name)
    verifyEqual(testCase, del.dim_in, dim_outin)
    verifyEqual(testCase, del.dim_out, dim_outin)
    verifyEqual(testCase, del.dim_in, del.dim_out)
    verifyEqual(testCase, del.lower_bound, -1.0)
    verifyEqual(testCase, del.upper_bound, 1.0)
    verifyEqual(testCase, del.lower_rate, -2.0)
    verifyEqual(testCase, del.upper_rate, 2.0)
    verifyEqual(testCase, del.horizon_period, [0, 1])
end

function testFourArgConstructor(testCase)
    name = 'test';
    dim_outin = 7;
    upper_bound = 4.5;
    lower_bound = -0.1;
    del = DeltaSltvRateBnd(name, dim_outin, lower_bound, upper_bound);
    verifyEqual(testCase, del.name, name)
    verifyEqual(testCase, del.dim_in, dim_outin)
    verifyEqual(testCase, del.dim_out, dim_outin)
    verifyEqual(testCase, del.dim_in, del.dim_out)
    verifyEqual(testCase, del.lower_bound, lower_bound)
    verifyEqual(testCase, del.upper_bound, upper_bound)
    verifyEqual(testCase, del.lower_rate, -abs(upper_bound - lower_bound))
    verifyEqual(testCase, del.upper_rate, abs(upper_bound - lower_bound))
    verifyEqual(testCase, del.horizon_period, [0, 1])
end

function testSixArgConstructor(testCase)
    name = 'test';
    dim_outin = 7;
    ub = 4.5;
    lb = -0.1;
    ur = .1;
    lr = -10;
    del = DeltaSltvRateBnd(name, dim_outin, lb, ub, lr, ur);
    verifyEqual(testCase, del.name, name)
    verifyEqual(testCase, del.dim_in, dim_outin)
    verifyEqual(testCase, del.dim_out, dim_outin)
    verifyEqual(testCase, del.dim_in, del.dim_out)
    verifyEqual(testCase, del.lower_bound, lb)
    verifyEqual(testCase, del.upper_bound, ub)
    verifyEqual(testCase, del.lower_rate, lr)
    verifyEqual(testCase, del.upper_rate, ur)
    verifyEqual(testCase, del.horizon_period, [0, 1])
end

function testFailedDeltaToMultiplier(testCase)
    name = 'test';
    del = DeltaSltvRateBnd(name);
    verifyError(testCase, @() deltaToMultiplier(del), ?MException);
end

function testFailedName(testCase)
    verifyError(testCase, @() DeltaSltvRateBnd(), ?MException)
    verifyError(testCase, @() DeltaSltvRateBnd(1), ?MException)
end

function testFailedDimension(testCase)
    verifyError(testCase, @() DeltaSltvRateBnd('test', -2), ?MException)
    verifyError(testCase, @() DeltaSltvRateBnd('test', 2.2), ?MException)
end

function testFailedBounds(testCase)
    hp = [2, 2];
    total_time = sum(hp);
    lb = -1.2 * ones(1,total_time);
    ub = linspace(4, 5, total_time);
    lb(total_time) = ub(total_time) + 1;

    verifyError(testCase, @() DeltaSltvRateBnd('test', 1, lb, ub, hp), ?MException)

    lb(total_time) = -inf;
    verifyError(testCase, @() DeltaSltvRateBnd('test', 1, lb, ub, hp), ?MException)

    lb(total_time) = ub(total_time) - 1;
    ub(1) = nan;
    verifyError(testCase, @() DeltaSltvRateBnd('test', 1, lb, ub, hp), ?MException)
end

function testFailedRate(testCase)
    hp = [2, 2];
    total_time = sum(hp);
    lr = -1.2 * ones(1,total_time);
    ur = linspace(4, 5, total_time);
    lr(total_time) = ur(total_time) + 1;

    verifyError(testCase,...
                @() DeltaSltvRateBnd('test', 1, -1, 1, lr, ur, hp),...
                ?MException)

    lr(total_time) = -inf;
    verifyError(testCase,...
                @() DeltaSltvRateBnd('test', 1, -1, 1, lr, ur, hp),...
                ?MException)

    lr(total_time) = ur(total_time) - 1;
    ur(1) = nan;
    verifyError(testCase,...
                @() DeltaSltvRateBnd('test', 1, -1, 1, lr, ur, hp),...
                ?MException)
end

function testHorizonPeriod(testCase)
   name = 'test';
   del = DeltaSltvRateBnd(name);
   assertEqual(testCase, del.horizon_period, [0, 1])
   
   % Checking horizon_period and making sure it fits for all properties
   horizon_period2 = [4, 3];
   total_time2 = sum(horizon_period2);
   lb = -1;
   ub = linspace(2, 3, total_time2);
   lr = -ones(1, total_time2);
   ur = 2;
   dim_outin2 = ones(1, total_time2);
   del = DeltaSltvRateBnd(name, dim_outin2, lb, ub, lr, ur, horizon_period2);
   del = matchHorizonPeriod(del);
   assertEqual(testCase, del.horizon_period, horizon_period2)
   assertEqual(testCase, del.lower_bound, lb * ones(1, total_time2))
   assertEqual(testCase, del.upper_bound, ub)
   assertEqual(testCase, del.dim_in, dim_outin2)
   assertEqual(testCase, del.dim_out, dim_outin2)

   % Resetting horizon_period and making sure it fits for all properties
   horizon_period3 = [total_time2, horizon_period2(2) * 2];
   total_time3 = sum(horizon_period3);
   dim_outin3 = ones(1, total_time3);
   del = matchHorizonPeriod(del, horizon_period3);
   verifyEqual(testCase, del.horizon_period, horizon_period3)
   verifyEqual(testCase, del.lower_bound, lb * ones(1, total_time3));
   verifyEqual(testCase,...
               del.upper_bound,...
               [ub,...
                ub((1:(horizon_period3(2) / 2)) + horizon_period2(1)),...
                ub((1:(horizon_period3(2) / 2)) + horizon_period2(1))])
   verifyEqual(testCase, del.dim_in,  dim_outin3)
   verifyEqual(testCase, del.dim_out, dim_outin3)
end

function testFailedHorizonPeriod(testCase)
   name = 'test';
   del = DeltaSltvRateBnd(name);
   assertEqual(testCase, del.horizon_period, [0, 1])
   
   % Resetting horizon_period and making sure it fits for all properties
   horizon_period2 = [4, 7];
   del.horizon_period = horizon_period2;
   del = matchHorizonPeriod(del);
   assertEqual(testCase, del.horizon_period, horizon_period2)
   
   % Resetting horizon_period and incorrectly trying to force a fit with
   % other properties
   horizon_period3 = [5, 3];
   horizon_period3 = commonHorizonPeriod([horizon_period2; horizon_period3]);
   del.horizon_period = horizon_period3;
   verifyError(testCase, @() matchHorizonPeriod(del), ?MException)
end

function testNormalization(testCase)
    rng(1647891347) 
    % 10 randomly generated LFTs
    for i = 1:10
        dim_outin = randi([1, 10]);
        hp = [randi([0, 10]), randi([1, 10])];
        total_time = sum(hp);
        upper_bound = 10 * rand(1, total_time);
        lower_bound = upper_bound - 20 * rand(1, total_time);
        upper_rate = 10 * rand(1, total_time);
        lower_rate = upper_rate - 20 * rand(1, total_time);
        
        width = upper_bound - lower_bound;
        del = DeltaSltvRateBnd('test', dim_outin,...
                               lower_bound, upper_bound,...
                               lower_rate, upper_rate,...
                               hp);
        lft = Ulft.random('num_deltas', 1,...
                          'req_deltas', {del},...
                          'horizon_period', hp);
        lft_n = normalizeLft(lft);
        
        % Check correctness
        % delta
        exp_lower_rate = 2 * lower_rate ./ width;
        exp_upper_rate = 2 * upper_rate ./ width;
        exp_lower_bnd = -ones(1, total_time);
        exp_upper_bnd = ones(1, total_time);
        verifyEqual(testCase, lft_n.delta.deltas{1}.lower_rate, exp_lower_rate,...
                    'RelTol', 1e-4)
        verifyEqual(testCase, lft_n.delta.deltas{1}.upper_rate, exp_upper_rate,...
                    'RelTol', 1e-4)
        verifyEqual(testCase, lft_n.delta.deltas{1}.lower_bound, exp_lower_bnd,...
                    'RelTol', 1e-4)
        verifyEqual(testCase, lft_n.delta.deltas{1}.upper_bound, exp_upper_bnd,...
                    'RelTol', 1e-4)
        % a, b, c, d (via sampling)
        for j = 1 :3
            kern = rand;
            for k = 1:total_time
                del_samp = (lower_bound(k) + width(k) * kern) * eye(dim_outin);
                del_n_samp = (-1 + 2 * kern) * eye(dim_outin);

                lft_samp = lft.d{k} + lft.c{k} * del_samp * ...
                           inv(eye(dim_outin) - lft.a{k} * del_samp) * ...
                           lft.b{k};
                lft_n_samp = lft_n.d{k} + lft_n.c{k} * del_n_samp * ...
                             inv(eye(dim_outin) - lft_n.a{k} * del_n_samp) * ...
                             lft_n.b{k};
                verifyLessThan(testCase,...
                               max(abs(lft_samp - lft_n_samp)),...
                               1e-4)
            end
        end
    end
end

end
end

%%  CHANGELOG
% Sep. 28, 2021 (v0.6.0)
% Aug. 26, 2021 (v.0.5.0): Initial release - Micah Fry (micah.fry@ll.mit.edu)