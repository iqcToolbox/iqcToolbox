%% Requirements:
%  1. IQC analysis shall produce an "infeasible problem" result when analyzing
%     constant time-delayed uncertain systems that are not robustly stable
%  2. IQC analysis shall produce an upper-bound on worst-case performance
%     for many constant delayed uncertain systems that are robustly stable. 
%     Producing an upper-bound for ALL delayed uncertain systems is not 
%     expected.

%%
%  Copyright (c) 2021 Massachusetts Institute of Technology 
%  SPDX-License-Identifier: GPL-2.0
%%

%% Test class for IQC analysis with constant time delays (out = delay (in))
classdef testIqcAnalysisConstantDelay < matlab.unittest.TestCase

methods (TestMethodSetup)
function seedAndReportRng(testCase)
    seed = floor(posixtime(datetime('now')));
    rng(seed, 'twister');
    diagnose_str = ...
        sprintf(['Random inputs may be regenerated by calling: \n',...
                 '>> rng(%10d) \n',...
                 'before running the remainder of the test''s body'],...
                seed);
    testCase.onFailure(@() fprintf(diagnose_str));
end    
end

methods (Test)
function testUpperBoundBetweenSltiAndDlti(testCase)
    % Simple test on sole operator
    
    dim_state = randi([1, 5]);    
    d_Z = DeltaDelayZ(dim_state);
    d_S = DeltaIntegrator(dim_state);
    
    dim_outin = randi([1, 10]);
    bound = 1;
    delay_max = randi([1, 10]);
    d_slti  = DeltaSlti('slti', dim_outin, -bound, bound);
    d_dlti  = DeltaDlti('dlti', dim_outin, dim_outin, bound);
    d_delay = DeltaConstantDelay('delay', dim_outin, delay_max);
    for i = 1:3
    % Repeat the following tests for memoryless, discrete-time, continuous-time systems
        switch i
            case 1
                g = drss(dim_state, dim_outin, dim_outin);
                g.a = 0.95 * g.a;
            case 2
                g = rss(dim_state, dim_outin, dim_outin);
                g.a = g.a - 0.05 * eye(size(g.a));
            case 3
                g = ss(randn(dim_outin, dim_outin));
        end
        g = g * 0.99 / norm(g, 'inf');
        eye_mat = eye(dim_outin);
        g = [eye_mat; eye_mat] * g * [eye_mat, eye_mat];
        if isempty(g.a)
            g = g.d;
        end
        lft_slti  = interconnect(toLft(d_slti), g);
        lft_dlti  = interconnect(toLft(d_dlti), g);
        lft_delay = interconnect(toLft(d_delay), g);

        options = AnalysisOptions('lmi_shift', 1e-6, 'verbose', false);
        result_slti = iqcAnalysis(lft_slti, 'analysis_options', options);
        testCase.verifyTrue(result_slti.valid);
        perf_slti = result_slti.performance;
        result_dlti = iqcAnalysis(lft_dlti, 'analysis_options', options);
        testCase.verifyTrue(result_dlti.valid);
        perf_dlti = result_dlti.performance;
        result_delay = iqcAnalysis(lft_delay, 'analysis_options', options);
        testCase.verifyTrue(result_delay.valid);
        perf_delay = result_delay.performance;
        if abs(perf_dlti - perf_slti) < 1e-4
            testCase.verifyLessThan(abs(perf_slti - perf_delay), 1e-4)
        else
            testCase.verifyLessThan(perf_slti, perf_dlti)
            testCase.verifyLessThan(perf_delay, perf_dlti)
            close_or_less = abs(perf_delay - perf_slti) < 1e-6 ...
                            || perf_slti < perf_delay;
            testCase.verifyTrue(close_or_less)        
            
        end
    end
end
end
end

%%  CHANGELOG
% Mar. 30, 2022: Added after v0.9.0 - Micah Fry (micah.fry@ll.mit.edu)