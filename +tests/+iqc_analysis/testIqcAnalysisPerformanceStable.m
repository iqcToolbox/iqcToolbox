%% Requirements:
%  1. IQC analysis shall produce an "infeasible problem" result when
%     analyzing uncertain systems that are not robustly stable
%  2. IQC analysis shall produce "feasible problem" result
%     for many uncertain systems that are robustly stable. 

%%
%  Copyright (c) 2021 Massachusetts Institute of Technology 
%  SPDX-License-Identifier: GPL-2.0
%%

%% Test class for IQC analysis with Sector-Bounded operators
classdef testIqcAnalysisPerformanceStable < matlab.unittest.TestCase

methods (TestMethodSetup)
function seedAndReportRng(testCase)
    seed = floor(posixtime(datetime('now')));
    rng(seed);
    diagnose_str = ...
        sprintf(['Random inputs may be regenerated by calling: \n',...
                 '>> rng(%10d) \n',...
                 'before running the remainder of the test''s body'],...
                seed);
    testCase.onFailure(@() fprintf(diagnose_str));
end    
end

methods (Test)
function testRandomStateSpaces(testCase)
    % Randomly generated rss, passes when stable, fails when not
    options = AnalysisOptions('verbose', false);
    num_tests = 2;
    % Continuous time
    for i = 1:num_tests
        % Create a stable system, check that it is stable
        g = rss;
        g.a = g.a - 0.01 * eye(size(g.a, 1));
        g_lft = toLft(g);
        g_lft = g_lft.addPerformance({PerformanceStable()});
        result = iqcAnalysis(g_lft, 'analysis_options', options);
        testCase.verifyTrue(result.valid)
        % Make it unstable, check that iqcAnalysis fails    
        g_lft.a{1} = g.a - 1.1 * max(real(eig(g.a))) * eye(size(g.a, 1));
        result = iqcAnalysis(g_lft, 'analysis_options', options);
        testCase.verifyFalse(result.valid)
    end
    % Discrete time
    for i = 1:num_tests
        % Create a stable system, check that it is stable
        g = drss;
        g.a = 0.95 * g.a;
        g_lft = toLft(g);
        g_lft = g_lft.addPerformance({PerformanceStable()});
        result = iqcAnalysis(g_lft, 'analysis_options', options);
        testCase.verifyTrue(result.valid)
        % Make it unstable, check that iqcAnalysis fails    
        g_lft.a{1} = 1.1 / max(abs(eig(g.a))) * g_lft.a{1};
        result = iqcAnalysis(g_lft, 'analysis_options', options);
        testCase.verifyFalse(result.valid)
    end
    % Time-varying
    for i = 1:num_tests
        lft = Ulft.random('num_deltas', 1, 'req_deltas', {'DeltaDelayZ'});
        lft = lft.addPerformance({PerformanceStable()});
        result = iqcAnalysis(lft, 'analysis_options', options);
        testCase.verifyTrue(result.valid)
        % Make it unstable
        lft.a = cellfun(@(a) 1.1 / max(abs(eig(a))) * a, lft.a,...
                          'UniformOutput', false);
        result = iqcAnalysis(lft, 'analysis_options', options);
        testCase.verifyFalse(result.valid)
    end
end

function testSmallGain(testCase)
    % Randomly generated rss, passes when stable, fails when not
    options = AnalysisOptions('verbose', false);
    num_tests = 2;
    % Continuous time
    for i = 1:num_tests
        % Create a robustly stable system, verify robust stability
        dim_state = randi([1, 10]);
        dim_out   = randi([2, 10]);
        dim_in    = randi([2, 10]);
        g = rss(dim_state, dim_out, dim_in);
        g.a = g.a - 0.01 * eye(size(g.a, 1));
        norm_g = norm(g(1:end-1, (1:end-1)), 'inf');
        d = DeltaBounded('d', dim_in - 1, dim_out - 1, 0.9 / norm_g);
        lower_lft = toLft(g);
        g_lft = interconnect(toLft(d), lower_lft);
        g_lft = g_lft.addPerformance({PerformanceStable()});
        result = iqcAnalysis(g_lft, 'analysis_options', options);
        testCase.verifyTrue(result.valid)
        % Make it unstable, check that iqcAnalysis fails    
        g_lft.delta.deltas{2}.upper_bound = 1.1 / 0.9 * d.upper_bound;
        result = iqcAnalysis(g_lft, 'analysis_options', options);
        testCase.verifyFalse(result.valid)
    end
    % Discrete time
    for i = 1:num_tests
        % Create a robustly stable system, verify robust stability
        dim_state = randi([1, 10]);
        dim_out   = randi([2, 10]);
        dim_in    = randi([2, 10]);
        g = drss(dim_state, dim_out, dim_in);
        g.a = 0.95 * g.a;
        norm_g = norm(g(1:end-1, (1:end-1)), 'inf');
        d = DeltaBounded('d', dim_in - 1, dim_out - 1, 0.9 / norm_g);
        lower_lft = toLft(g);
        g_lft = interconnect(toLft(d), lower_lft);
        g_lft = g_lft.addPerformance({PerformanceStable()});
        result = iqcAnalysis(g_lft, 'analysis_options', options);
        testCase.verifyTrue(result.valid)
        % Make it unstable, check that iqcAnalysis fails    
        g_lft.delta.deltas{2}.upper_bound = 1.1 / 0.9 * d.upper_bound;
        result = iqcAnalysis(g_lft, 'analysis_options', options);
        testCase.verifyFalse(result.valid)
    end
    % Time-varying
    for i = 1:num_tests
        dim_out   = randi([2, 10]);
        dim_in    = randi([2, 10]);
        norm_g = Inf;
        while isinf(norm_g)
            lower_lft = Ulft.random('num_deltas', 1,...
                                    'req_deltas', {'DeltaDelayZ'},...
                                    'dim_out', dim_out,...
                                    'dim_in', dim_in);
            upper_in = [eye(dim_in - 1); zeros(1, dim_in - 1)];
            upper_out = [eye(dim_out - 1), zeros(dim_out - 1, 1)];
            result = iqcAnalysis(upper_out * lower_lft * upper_in,...
                                 'analysis_options', options);
            norm_g = result.performance;
        end
        d = DeltaBounded('d',...
                         dim_in - 1,...
                         dim_out - 1,...
                         0.9 / norm_g, lower_lft.horizon_period);
        lft = interconnect(toLft(d), lower_lft);        
        lft = lft.addPerformance({PerformanceStable()});
        result = iqcAnalysis(lft, 'analysis_options', options);
        testCase.verifyTrue(result.valid)
        % Make it unstable
        lft.delta.deltas{2}.upper_bound = 1.1 / 0.9 * d.upper_bound;
        result = iqcAnalysis(lft, 'analysis_options', options);
        testCase.verifyFalse(result.valid)
    end
end

function testPassiveTheorems(testCase)
    % Interconnection of passive components is robustly stable (Khalil Lemma 6.8)
    lower_lft = [-toLft(DeltaPassive('del_low')), 1; 1, 0];
    upper_lft = toLft(DeltaPassive('del_up'));
    lft = interconnect(upper_lft, lower_lft);
    lft = lft.addPerformance({PerformanceStable()});
    result = iqcAnalysis(lft);
    testCase.verifyTrue(result.valid)
    
    % Interconnection of strictly passive TF with passive operator is robustly stable (Khalil Theorem 6.4)
    % This will fail on PerformanceL2Induced because of the extra positive diagonal term
    g_tf = ss(tf(1/(tf('z') + .5))) + 2;
    g = ss([-g_tf, g_tf; 1, 0]);
    g_lft = toLft(g);
    del = DeltaPassive('del_up');
    lft = interconnect(toLft(del), g_lft);
    lft = lft.addPerformance({PerformanceStable()});
    options = AnalysisOptions('lmi_shift', 1e-12, 'verbose', false);
    result = iqcAnalysis(lft, 'analysis_options', options);
    testCase.verifyTrue(result.valid)
    % Check that this fails when doing L2 induced performance
    lft = lft.removePerformance(1);
    result = iqcAnalysis(lft, 'analysis_options', options);
    testCase.verifyFalse(result.valid)
    
    m = 1;
    k1 = 2;
    k2 = 3;
    s = tf('s');
    g_tf = s / (m * s^2 + k2 * s + k1);
    g_tf = 1 / (s + .05);
    g = ss([-g_tf, g_tf; 1, 0]);
    g_lft = toLft(g);
    del = DeltaPassive('del_up');
    lft = interconnect(toLft(del), g_lft);
    lft = lft.addPerformance({PerformanceStable()});
    shift = 1e-10;
    options = AnalysisOptions('lmi_shift', shift, 'verbose', false);
    result = iqcAnalysis(lft, 'analysis_options', options);
    residual = check(result.debug.constraints(2));
    testCase.verifyTrue(result.valid || shift + residual > -2 * eps)
    % Check that this fails when doing L2 induced performance
    lft = lft.removePerformance(1);
    result = iqcAnalysis(lft, 'analysis_options', options);
    residual = check(result.debug.constraints(2));
    testCase.verifyFalse(result.valid && shift + residual <= -2 * eps)    
end


end
end

%%  CHANGELOG
% Feb. 17, 2021: Added after v0.6.0 - Micah Fry (micah.fry@ll.mit.edu)